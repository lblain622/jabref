


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MultiMergeEntriesView</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.gui.mergeentries.multiwaymerge</a>
</div>

<h1>Coverage Summary for Class: MultiMergeEntriesView (org.jabref.gui.mergeentries.multiwaymerge)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MultiMergeEntriesView</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/95)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MultiMergeEntriesView$Cell</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MultiMergeEntriesView$FieldRow</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/178)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.gui.mergeentries.multiwaymerge;
&nbsp;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.function.Supplier;
&nbsp;
&nbsp;import javafx.collections.FXCollections;
&nbsp;import javafx.collections.ListChangeListener;
&nbsp;import javafx.collections.MapChangeListener;
&nbsp;import javafx.fxml.FXML;
&nbsp;import javafx.scene.control.Button;
&nbsp;import javafx.scene.control.ButtonBar;
&nbsp;import javafx.scene.control.ButtonType;
&nbsp;import javafx.scene.control.ComboBox;
&nbsp;import javafx.scene.control.ContentDisplay;
&nbsp;import javafx.scene.control.Control;
&nbsp;import javafx.scene.control.Label;
&nbsp;import javafx.scene.control.ProgressIndicator;
&nbsp;import javafx.scene.control.ScrollPane;
&nbsp;import javafx.scene.control.TextArea;
&nbsp;import javafx.scene.control.TextField;
&nbsp;import javafx.scene.control.TextInputControl;
&nbsp;import javafx.scene.control.ToggleButton;
&nbsp;import javafx.scene.control.ToggleGroup;
&nbsp;import javafx.scene.control.Tooltip;
&nbsp;import javafx.scene.input.KeyEvent;
&nbsp;import javafx.scene.layout.ColumnConstraints;
&nbsp;import javafx.scene.layout.GridPane;
&nbsp;import javafx.scene.layout.HBox;
&nbsp;import javafx.scene.layout.Priority;
&nbsp;import javafx.scene.layout.Region;
&nbsp;import javafx.scene.layout.RowConstraints;
&nbsp;import javafx.scene.layout.VBox;
&nbsp;import javafx.scene.text.TextAlignment;
&nbsp;
&nbsp;import org.jabref.gui.icon.IconTheme;
&nbsp;import org.jabref.gui.mergeentries.DiffMode;
&nbsp;import org.jabref.gui.preferences.GuiPreferences;
&nbsp;import org.jabref.gui.util.BaseDialog;
&nbsp;import org.jabref.gui.util.BindingsHelper;
&nbsp;import org.jabref.gui.util.UiTaskExecutor;
&nbsp;import org.jabref.gui.util.ViewModelListCellFactory;
&nbsp;import org.jabref.logic.importer.FetcherException;
&nbsp;import org.jabref.logic.importer.fetcher.DoiFetcher;
&nbsp;import org.jabref.logic.l10n.Localization;
&nbsp;import org.jabref.logic.util.TaskExecutor;
&nbsp;import org.jabref.model.entry.BibEntry;
&nbsp;import org.jabref.model.entry.field.Field;
&nbsp;import org.jabref.model.entry.field.FieldFactory;
&nbsp;import org.jabref.model.entry.field.FieldTextMapper;
&nbsp;import org.jabref.model.entry.field.StandardField;
&nbsp;
&nbsp;import com.airhacks.afterburner.views.ViewLoader;
&nbsp;import com.tobiasdiez.easybind.EasyBind;
&nbsp;import com.tobiasdiez.easybind.EasyObservableValue;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;public class MultiMergeEntriesView extends BaseDialog&lt;BibEntry&gt; {
&nbsp;    public static final int ACTIVE_COLUMNS_MINIMUM = 2;
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(MultiMergeEntriesView.class);</b>
&nbsp;
&nbsp;    // LEFT
&nbsp;    @FXML private ScrollPane leftScrollPane;
&nbsp;    @FXML private VBox fieldHeader;
&nbsp;
&nbsp;    // CENTER
&nbsp;    @FXML private ScrollPane topScrollPane;
&nbsp;    @FXML private HBox supplierHeader;
&nbsp;    @FXML private ScrollPane centerScrollPane;
&nbsp;    @FXML private GridPane optionsGrid;
&nbsp;
&nbsp;    // RIGHT
&nbsp;    @FXML private ScrollPane rightScrollPane;
&nbsp;    @FXML private VBox fieldEditor;
&nbsp;
&nbsp;    @FXML private Label failedSuppliers;
&nbsp;    @FXML private ComboBox&lt;DiffMode&gt; diffMode;
&nbsp;
<b class="nc">&nbsp;    private final ToggleGroup headerToggleGroup = new ToggleGroup();</b>
<b class="nc">&nbsp;    private final HashMap&lt;Field, FieldRow&gt; fieldRows = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    private final MultiMergeEntriesViewModel viewModel;
&nbsp;    private final TaskExecutor taskExecutor;
&nbsp;
&nbsp;    private final GuiPreferences preferences;
&nbsp;
&nbsp;    public MultiMergeEntriesView(GuiPreferences preferences,
<b class="nc">&nbsp;                                 TaskExecutor taskExecutor) {</b>
<b class="nc">&nbsp;        this.preferences = preferences;</b>
<b class="nc">&nbsp;        this.taskExecutor = taskExecutor;</b>
&nbsp;
<b class="nc">&nbsp;        viewModel = new MultiMergeEntriesViewModel();</b>
&nbsp;
<b class="nc">&nbsp;        ViewLoader.view(this)</b>
<b class="nc">&nbsp;                  .load()</b>
<b class="nc">&nbsp;                  .setAsDialogPane(this);</b>
&nbsp;
<b class="nc">&nbsp;        ButtonType mergeEntries = new ButtonType(Localization.lang(&quot;Merge entries&quot;), ButtonBar.ButtonData.OK_DONE);</b>
<b class="nc">&nbsp;        this.getDialogPane().getButtonTypes().setAll(ButtonType.CANCEL, mergeEntries);</b>
<b class="nc">&nbsp;        this.setResultConverter(viewModel::resultConverter);</b>
&nbsp;
<b class="nc">&nbsp;        viewModel.entriesProperty().addListener((ListChangeListener&lt;MultiMergeEntriesViewModel.EntrySource&gt;) c -&gt; {</b>
<b class="nc">&nbsp;            while (c.next()) {</b>
<b class="nc">&nbsp;                if (c.wasAdded()) {</b>
<b class="nc">&nbsp;                    for (MultiMergeEntriesViewModel.EntrySource entrySourceColumn : c.getAddedSubList()) {</b>
<b class="nc">&nbsp;                        addColumn(entrySourceColumn);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        viewModel.mergedEntryProperty().get().getFieldsObservable().addListener((MapChangeListener&lt;Field, String&gt;) change -&gt; {</b>
<b class="nc">&nbsp;            if (change.wasAdded() &amp;&amp; !fieldRows.containsKey(change.getKey())) {</b>
<b class="nc">&nbsp;                FieldRow fieldRow = new FieldRow(</b>
<b class="nc">&nbsp;                        change.getKey(),</b>
<b class="nc">&nbsp;                        viewModel.mergedEntryProperty().get().getFields().size() - 1);</b>
<b class="nc">&nbsp;                fieldRows.put(change.getKey(), fieldRow);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @FXML
&nbsp;    public void initialize() {
<b class="nc">&nbsp;        topScrollPane.hvalueProperty().bindBidirectional(centerScrollPane.hvalueProperty());</b>
<b class="nc">&nbsp;        leftScrollPane.vvalueProperty().bindBidirectional(centerScrollPane.vvalueProperty());</b>
<b class="nc">&nbsp;        rightScrollPane.vvalueProperty().bindBidirectional(centerScrollPane.vvalueProperty());</b>
&nbsp;
<b class="nc">&nbsp;        viewModel.failedSuppliersProperty().addListener((_, _, _) -&gt; {</b>
<b class="nc">&nbsp;            failedSuppliers.setText(viewModel.failedSuppliersProperty().get().isEmpty() ? &quot;&quot; : Localization.lang(</b>
&nbsp;                    &quot;Could not extract Metadata from: %0&quot;,
<b class="nc">&nbsp;                    String.join(&quot;, &quot;, viewModel.failedSuppliersProperty())));</b>
<b class="nc">&nbsp;            int activeColumns = viewModel.entriesProperty().get().size() - viewModel.failedSuppliersProperty().get().size();</b>
<b class="nc">&nbsp;            if (activeColumns &lt; ACTIVE_COLUMNS_MINIMUM) {</b>
&nbsp;                // [impl-&gt;req~ux.auto-close.merge-entries~1]
&nbsp;                close();
&nbsp;            }
&nbsp;        });
<b class="nc">&nbsp;        fillDiffModes();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void fillDiffModes() {
<b class="nc">&nbsp;        diffMode.setItems(FXCollections.observableList(List.of(</b>
&nbsp;                DiffMode.PLAIN,
&nbsp;                DiffMode.WORD,
&nbsp;                DiffMode.CHARACTER)));
<b class="nc">&nbsp;        new ViewModelListCellFactory&lt;DiffMode&gt;()</b>
<b class="nc">&nbsp;                .withText(DiffMode::getDisplayText)</b>
<b class="nc">&nbsp;                .install(diffMode);</b>
<b class="nc">&nbsp;        diffMode.setValue(preferences.getMergeDialogPreferences().getMergeDiffMode());</b>
<b class="nc">&nbsp;        EasyBind.subscribe(this.diffMode.valueProperty(), mode -&gt; preferences.getMergeDialogPreferences().setMergeDiffMode(mode));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addColumn(MultiMergeEntriesViewModel.EntrySource entrySourceColumn) {
&nbsp;        // add header
<b class="nc">&nbsp;        int columnIndex = supplierHeader.getChildren().size();</b>
<b class="nc">&nbsp;        ToggleButton header = generateEntryHeader(entrySourceColumn, columnIndex);</b>
<b class="nc">&nbsp;        header.getStyleClass().add(&quot;toggle-button&quot;);</b>
<b class="nc">&nbsp;        HBox.setHgrow(header, Priority.ALWAYS);</b>
<b class="nc">&nbsp;        supplierHeader.getChildren().add(header);</b>
<b class="nc">&nbsp;        header.setMinWidth(250);</b>
&nbsp;
&nbsp;        // setup column constraints
<b class="nc">&nbsp;        ColumnConstraints constraint = new ColumnConstraints();</b>
<b class="nc">&nbsp;        constraint.setMinWidth(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;        constraint.setMaxWidth(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;        constraint.prefWidthProperty().bind(header.widthProperty());</b>
<b class="nc">&nbsp;        optionsGrid.getColumnConstraints().add(constraint);</b>
&nbsp;
&nbsp;        // Copy BibEntry to column - either immediately (if available) or after loading
<b class="nc">&nbsp;        if (!entrySourceColumn.isLoadingProperty().getValue()) {</b>
<b class="nc">&nbsp;            writeBibEntryToColumn(entrySourceColumn, columnIndex);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            header.setDisable(true);</b>
<b class="nc">&nbsp;            entrySourceColumn.isLoadingProperty().addListener((_, _, newValue) -&gt; {</b>
<b class="nc">&nbsp;                if (!newValue &amp;&amp; entrySourceColumn.entryProperty().get() != null) {</b>
<b class="nc">&nbsp;                    writeBibEntryToColumn(entrySourceColumn, columnIndex);</b>
<b class="nc">&nbsp;                    header.setDisable(false);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private ToggleButton generateEntryHeader(MultiMergeEntriesViewModel.EntrySource column, int columnIndex) {
<b class="nc">&nbsp;        ToggleButton header = new ToggleButton();</b>
<b class="nc">&nbsp;        header.setToggleGroup(headerToggleGroup);</b>
<b class="nc">&nbsp;        header.textProperty().bind(column.titleProperty());</b>
<b class="nc">&nbsp;        setupSourceButtonAction(header, columnIndex);</b>
&nbsp;
<b class="nc">&nbsp;        if (column.isLoadingProperty().getValue()) {</b>
<b class="nc">&nbsp;            ProgressIndicator progressIndicator = new ProgressIndicator(-1);</b>
<b class="nc">&nbsp;            progressIndicator.setPrefHeight(20);</b>
<b class="nc">&nbsp;            progressIndicator.setMinHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;            progressIndicator.setMaxHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;            header.setGraphic(progressIndicator);</b>
<b class="nc">&nbsp;            progressIndicator.visibleProperty().bind(column.isLoadingProperty());</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        column.isLoadingProperty().addListener((obs, oldValue, newValue) -&gt; {</b>
<b class="nc">&nbsp;            if (!newValue) {</b>
<b class="nc">&nbsp;                header.setGraphic(null);</b>
<b class="nc">&nbsp;                if (column.entryProperty().get() == null) {</b>
<b class="nc">&nbsp;                    header.setMinWidth(0);</b>
<b class="nc">&nbsp;                    header.setMaxWidth(0);</b>
<b class="nc">&nbsp;                    header.setVisible(false);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;
<b class="nc">&nbsp;        return header;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds ToggleButtons for all fields that are set for this BibEntry
&nbsp;     *
&nbsp;     * @param entrySourceColumn the entry to write
&nbsp;     * @param columnIndex       the index of the column to write this entry to
&nbsp;     */
&nbsp;    private void writeBibEntryToColumn(MultiMergeEntriesViewModel.EntrySource entrySourceColumn, int columnIndex) {
<b class="nc">&nbsp;        for (Map.Entry&lt;Field, String&gt; entry : entrySourceColumn.entryProperty().get().getFieldsObservable().entrySet()) {</b>
<b class="nc">&nbsp;            Field key = entry.getKey();</b>
<b class="nc">&nbsp;            String value = entry.getValue();</b>
<b class="nc">&nbsp;            Cell cell = new Cell(value, key, columnIndex);</b>
<b class="nc">&nbsp;            optionsGrid.add(cell, columnIndex, fieldRows.get(key).rowIndex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set up the button that displays the name of the source so that if it is clicked, all toggles in that column are
&nbsp;     * selected.
&nbsp;     *
&nbsp;     * @param sourceButton the header button to setup
&nbsp;     * @param column       the column this button is heading
&nbsp;     */
&nbsp;    private void setupSourceButtonAction(ToggleButton sourceButton, int column) {
<b class="nc">&nbsp;        sourceButton.selectedProperty().addListener((observable, oldValue, newValue) -&gt; {</b>
<b class="nc">&nbsp;            if (newValue) {</b>
<b class="nc">&nbsp;                optionsGrid.getChildrenUnmodifiable().stream()</b>
<b class="nc">&nbsp;                           .filter(node -&gt; GridPane.getColumnIndex(node) == column)</b>
<b class="nc">&nbsp;                           .filter(HBox.class::isInstance)</b>
<b class="nc">&nbsp;                           .forEach(hbox -&gt; ((HBox) hbox).getChildrenUnmodifiable().stream()</b>
<b class="nc">&nbsp;                                                         .filter(ToggleButton.class::isInstance)</b>
<b class="nc">&nbsp;                                                         .forEach(toggleButton -&gt; ((ToggleButton) toggleButton).setSelected(true)));</b>
<b class="nc">&nbsp;                sourceButton.setSelected(true);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the Field can be multiline
&nbsp;     *
&nbsp;     * @param field the field to be checked
&nbsp;     * @return true if the field may be multiline, false otherwise
&nbsp;     */
&nbsp;    private boolean isMultilineField(Field field) {
<b class="nc">&nbsp;        if (field.equals(StandardField.DOI)) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return FieldFactory.isMultiLineField(field, preferences.getFieldPreferences().getNonWrappableFields());</b>
&nbsp;    }
&nbsp;
&nbsp;    private class Cell extends HBox {
&nbsp;
&nbsp;        private final String content;
&nbsp;
<b class="nc">&nbsp;        public Cell(String content, Field field, int columnIndex) {</b>
<b class="nc">&nbsp;            this.content = content;</b>
&nbsp;
&nbsp;            /*
&nbsp;            If this is not explicitly done on the JavaFX thread, the bindings to the text fields don&#39;t work properly.
&nbsp;            The text only shows up after one text in that same row is selected by the user.
&nbsp;             */
<b class="nc">&nbsp;            UiTaskExecutor.runInJavaFXThread(() -&gt; {</b>
&nbsp;
<b class="nc">&nbsp;                FieldRow row = fieldRows.get(field);</b>
&nbsp;
<b class="nc">&nbsp;                prefWidthProperty().bind(((Region) supplierHeader.getChildren().get(columnIndex)).widthProperty());</b>
<b class="nc">&nbsp;                setMinWidth(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;                setMaxWidth(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;                prefHeightProperty().bind(((Region) fieldEditor.getChildren().get(row.rowIndex)).heightProperty());</b>
<b class="nc">&nbsp;                setMinHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;                setMaxHeight(Control.USE_PREF_SIZE);</b>
&nbsp;
&nbsp;                // Button
<b class="nc">&nbsp;                ToggleButton cellButton = new ToggleButton();</b>
<b class="nc">&nbsp;                cellButton.prefHeightProperty().bind(heightProperty());</b>
<b class="nc">&nbsp;                cellButton.setMinHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;                cellButton.setMaxHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;                cellButton.setGraphicTextGap(0);</b>
<b class="nc">&nbsp;                getChildren().add(cellButton);</b>
<b class="nc">&nbsp;                cellButton.maxWidthProperty().bind(widthProperty());</b>
<b class="nc">&nbsp;                HBox.setHgrow(cellButton, Priority.ALWAYS);</b>
&nbsp;
&nbsp;                // Text
<b class="nc">&nbsp;                DiffHighlightingEllipsingTextFlow buttonText = new DiffHighlightingEllipsingTextFlow(content, viewModel.mergedEntryProperty().get().getFieldBinding(field).asOrdinary(), diffMode.valueProperty());</b>
&nbsp;
<b class="nc">&nbsp;                buttonText.maxWidthProperty().bind(widthProperty().add(-10));</b>
<b class="nc">&nbsp;                buttonText.maxHeightProperty().bind(heightProperty());</b>
<b class="nc">&nbsp;                cellButton.setGraphic(buttonText);</b>
<b class="nc">&nbsp;                cellButton.setContentDisplay(ContentDisplay.GRAPHIC_ONLY);</b>
<b class="nc">&nbsp;                cellButton.setContentDisplay(ContentDisplay.CENTER);</b>
&nbsp;
&nbsp;                // Tooltip
<b class="nc">&nbsp;                Tooltip buttonTooltip = new Tooltip(content);</b>
<b class="nc">&nbsp;                buttonTooltip.setWrapText(true);</b>
<b class="nc">&nbsp;                buttonTooltip.prefWidthProperty().bind(widthProperty());</b>
<b class="nc">&nbsp;                buttonTooltip.setTextAlignment(TextAlignment.LEFT);</b>
<b class="nc">&nbsp;                cellButton.setTooltip(buttonTooltip);</b>
&nbsp;
<b class="nc">&nbsp;                cellButton.setToggleGroup(row.toggleGroup);</b>
<b class="nc">&nbsp;                if (row.toggleGroup.getSelectedToggle() == null) {</b>
<b class="nc">&nbsp;                    cellButton.setSelected(true);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (field.equals(StandardField.DOI)) {</b>
<b class="nc">&nbsp;                    Button doiButton = IconTheme.JabRefIcons.LOOKUP_IDENTIFIER.asButton();</b>
<b class="nc">&nbsp;                    HBox.setHgrow(doiButton, Priority.NEVER);</b>
<b class="nc">&nbsp;                    doiButton.prefHeightProperty().bind(cellButton.heightProperty());</b>
<b class="nc">&nbsp;                    doiButton.setMinHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;                    doiButton.setMaxHeight(Control.USE_PREF_SIZE);</b>
&nbsp;
<b class="nc">&nbsp;                    getChildren().add(doiButton);</b>
&nbsp;
<b class="nc">&nbsp;                    doiButton.setOnAction(event -&gt; {</b>
<b class="nc">&nbsp;                        DoiFetcher doiFetcher = new DoiFetcher(preferences.getImportFormatPreferences());</b>
<b class="nc">&nbsp;                        doiButton.setDisable(true);</b>
<b class="nc">&nbsp;                        addSource(Localization.lang(&quot;From DOI&quot;), () -&gt; {</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                return doiFetcher.performSearchById(content).get();</b>
&nbsp;                            } catch (FetcherException | NoSuchElementException e) {
<b class="nc">&nbsp;                                LOGGER.warn(&quot;Failed to fetch BibEntry for DOI {}&quot;, content, e);</b>
<b class="nc">&nbsp;                                return null;</b>
&nbsp;                            }
&nbsp;                        });
&nbsp;                    });
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;
&nbsp;        public String getContent() {
<b class="nc">&nbsp;            return content;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void addSource(String title, BibEntry entry) {
<b class="nc">&nbsp;        viewModel.addSource(new MultiMergeEntriesViewModel.EntrySource(title, entry));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addSource(String title, Supplier&lt;BibEntry&gt; supplier) {
<b class="nc">&nbsp;        viewModel.addSource(new MultiMergeEntriesViewModel.EntrySource(title, supplier, taskExecutor));</b>
&nbsp;    }
&nbsp;
&nbsp;    private class FieldRow {
&nbsp;
<b class="nc">&nbsp;        public final ToggleGroup toggleGroup = new ToggleGroup();</b>
&nbsp;        private final TextInputControl fieldEditorCell;
&nbsp;
&nbsp;        private final int rowIndex;
&nbsp;
&nbsp;        // Reference needs to be kept, since java garbage collection would otherwise destroy the subscription
&nbsp;        @SuppressWarnings(&quot;FieldCanBeLocal&quot;) private EasyObservableValue&lt;String&gt; fieldBinding;
&nbsp;
<b class="nc">&nbsp;        public FieldRow(Field field, int rowIndex) {</b>
<b class="nc">&nbsp;            this.rowIndex = rowIndex;</b>
&nbsp;
&nbsp;            // setup field editor column entry
<b class="nc">&nbsp;            boolean isMultiLine = isMultilineField(field);</b>
<b class="nc">&nbsp;            if (isMultiLine) {</b>
<b class="nc">&nbsp;                fieldEditorCell = new TextArea();</b>
<b class="nc">&nbsp;                ((TextArea) fieldEditorCell).setWrapText(true);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                fieldEditorCell = new TextField();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            addRow(field);</b>
&nbsp;
<b class="nc">&nbsp;            fieldEditorCell.addEventFilter(KeyEvent.KEY_PRESSED, event -&gt; toggleGroup.selectToggle(null));</b>
&nbsp;
<b class="nc">&nbsp;            toggleGroup.selectedToggleProperty().addListener((_, _, newValue) -&gt; {</b>
<b class="nc">&nbsp;                if (newValue == null) {</b>
<b class="nc">&nbsp;                    viewModel.mergedEntryProperty().get().setField(field, &quot;&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    viewModel.mergedEntryProperty().get().setField(field, ((DiffHighlightingEllipsingTextFlow) ((ToggleButton) newValue).getGraphic()).getFullText());</b>
<b class="nc">&nbsp;                    headerToggleGroup.selectToggle(null);</b>
&nbsp;                }
&nbsp;            });
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Adds a row that represents this field
&nbsp;         *
&nbsp;         * @param field the field to add to the view as a new row in the table
&nbsp;         */
&nbsp;        private void addRow(Field field) {
<b class="nc">&nbsp;            VBox.setVgrow(fieldEditorCell, Priority.ALWAYS);</b>
&nbsp;
<b class="nc">&nbsp;            fieldBinding = viewModel.mergedEntryProperty().get().getFieldBinding(field).asOrdinary();</b>
<b class="nc">&nbsp;            BindingsHelper.bindBidirectional(</b>
<b class="nc">&nbsp;                    fieldEditorCell.textProperty(),</b>
&nbsp;                    fieldBinding,
&nbsp;                    text -&gt; {
<b class="nc">&nbsp;                        if (text != null) {</b>
<b class="nc">&nbsp;                            fieldEditorCell.setText(text);</b>
&nbsp;                        }
&nbsp;                    },
&nbsp;                    binding -&gt; {
<b class="nc">&nbsp;                        if (binding != null) {</b>
<b class="nc">&nbsp;                            viewModel.mergedEntryProperty().get().setField(field, binding);</b>
&nbsp;                        }
&nbsp;                    });
&nbsp;
<b class="nc">&nbsp;            fieldEditorCell.setMaxHeight(Double.MAX_VALUE);</b>
<b class="nc">&nbsp;            VBox.setVgrow(fieldEditorCell, Priority.ALWAYS);</b>
<b class="nc">&nbsp;            fieldEditor.getChildren().add(fieldEditorCell);</b>
&nbsp;
&nbsp;            // setup header label
<b class="nc">&nbsp;            Label fieldHeaderLabel = new Label(FieldTextMapper.getDisplayName(field));</b>
<b class="nc">&nbsp;            fieldHeaderLabel.prefHeightProperty().bind(fieldEditorCell.heightProperty());</b>
<b class="nc">&nbsp;            fieldHeaderLabel.setMaxWidth(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;            fieldHeaderLabel.setMinWidth(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;            fieldHeader.getChildren().add(fieldHeaderLabel);</b>
&nbsp;
&nbsp;            // setup RowConstraints
<b class="nc">&nbsp;            RowConstraints constraint = new RowConstraints();</b>
<b class="nc">&nbsp;            constraint.setMinHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;            constraint.setMaxHeight(Control.USE_PREF_SIZE);</b>
<b class="nc">&nbsp;            constraint.prefHeightProperty().bind(fieldEditorCell.heightProperty());</b>
<b class="nc">&nbsp;            optionsGrid.getRowConstraints().add(constraint);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
