


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > WalkthroughUtils</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.gui.walkthrough.utils</a>
</div>

<h1>Coverage Summary for Class: WalkthroughUtils (org.jabref.gui.walkthrough.utils)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">WalkthroughUtils</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
</tr>
  <tr>
    <td class="name">WalkthroughUtils$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WalkthroughUtils$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WalkthroughUtils$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">WalkthroughUtils$DebouncedInvalidationListener</td>
  </tr>
  <tr>
    <td class="name">WalkthroughUtils$DebouncedRunnable</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.gui.walkthrough.utils;
&nbsp;
&nbsp;import java.util.function.BooleanSupplier;
&nbsp;
&nbsp;import javafx.animation.KeyFrame;
&nbsp;import javafx.animation.Timeline;
&nbsp;import javafx.beans.InvalidationListener;
&nbsp;import javafx.beans.Observable;
&nbsp;import javafx.collections.ListChangeListener;
&nbsp;import javafx.scene.Node;
&nbsp;import javafx.stage.Window;
&nbsp;import javafx.util.Duration;
&nbsp;
&nbsp;import com.sun.javafx.scene.NodeHelper;
&nbsp;import org.jspecify.annotations.NonNull;
&nbsp;import org.jspecify.annotations.Nullable;
&nbsp;
<b class="nc">&nbsp;public class WalkthroughUtils {</b>
&nbsp;    public static final long DEFAULT_DEBOUNCE = 100L;
&nbsp;
&nbsp;    public static boolean isNodeVisible(@Nullable Node node) {
<b class="nc">&nbsp;        return node != null &amp;&amp; NodeHelper.isTreeVisible(node);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean cannotPositionNode(@Nullable Node node) {
<b class="nc">&nbsp;        return node == null || node.getScene() == null || !isNodeVisible(node) || node.getBoundsInLocal().isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    public interface DebouncedInvalidationListener extends InvalidationListener {
&nbsp;        /// Cancel any debounced InvalidationListener that&#39;s scheduled to run in the
&nbsp;        /// future.
&nbsp;        ///
&nbsp;        /// @implNote In other words, the implementation of debounced is NOT actually
&nbsp;        /// putting a counter of how many times the methods have executed, but rather to
&nbsp;        /// always delay the execution to specified intervals later, for which, only if
&nbsp;        /// during the specified interval no other tasks are scheduled, the operation
&nbsp;        /// proceeds. Therefore, you are likely interested in calling this method to
&nbsp;        /// prevent unwanted execution.
&nbsp;        void cancel();
&nbsp;    }
&nbsp;
&nbsp;    /// Creates a debounced InvalidationListener that limits execution to at most once
&nbsp;    /// per interval. Uses JavaFX Timeline to ensure execution on JavaFX Application
&nbsp;    /// Thread.
&nbsp;    ///
&nbsp;    /// You are probably interested in calling the
&nbsp;    /// [DebouncedInvalidationListener#cancel()] methods when you clean up. Otherwise,
&nbsp;    /// there is a chance that this listener will run your methods after you removed it
&nbsp;    /// from all the properties that it is attached to.
&nbsp;    ///
&nbsp;    /// @param listener the listener to debounce
&nbsp;    /// @return a debounced listener
&nbsp;    public static DebouncedInvalidationListener debounced(InvalidationListener listener) {
<b class="nc">&nbsp;        return debounced(listener, DEFAULT_DEBOUNCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Creates a debounced InvalidationListener that limits execution to at most once
&nbsp;    /// per interval. Uses JavaFX Timeline to ensure execution on JavaFX Application
&nbsp;    /// Thread.
&nbsp;    ///
&nbsp;    /// You are probably interested in calling the
&nbsp;    /// [DebouncedInvalidationListener#cancel()] methods when you clean up. Otherwise,
&nbsp;    /// there is a chance that this listener will run your methods after you removed it
&nbsp;    /// from all the properties that it is attached to.
&nbsp;    ///
&nbsp;    /// @param listener   the listener to debounce
&nbsp;    /// @param intervalMs the minimum interval between executions in milliseconds
&nbsp;    /// @return a debounced listener
&nbsp;    public static DebouncedInvalidationListener debounced(InvalidationListener listener, long intervalMs) {
<b class="nc">&nbsp;        Timeline timeline = new Timeline();</b>
&nbsp;
<b class="nc">&nbsp;        return new DebouncedInvalidationListener() {</b>
&nbsp;            @Override
&nbsp;            public void cancel() {
<b class="nc">&nbsp;                timeline.stop();</b>
<b class="nc">&nbsp;                timeline.getKeyFrames().clear();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void invalidated(Observable observable) {
<b class="nc">&nbsp;                Runnable action = () -&gt; listener.invalidated(observable);</b>
<b class="nc">&nbsp;                scheduleExecution(timeline, intervalMs, action);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    public interface DebouncedRunnable extends Runnable {
&nbsp;        /// Cancel any debounced Runnable that&#39;s scheduled to run in the future.
&nbsp;        ///
&nbsp;        /// @implNote In other words, the implementation of debounced is NOT actually
&nbsp;        /// putting a counter of how many times the methods have executed, but rather to
&nbsp;        /// always delay the execution to specified intervals later, for which, only if
&nbsp;        /// during the specified interval no other tasks are scheduled, the operation
&nbsp;        /// proceeds. Therefore, you are likely interested in calling this method to
&nbsp;        /// prevent unwanted execution.
&nbsp;        void cancel();
&nbsp;    }
&nbsp;
&nbsp;    /// Creates a debounced Runnable that limits execution to at most once per interval.
&nbsp;    /// Uses JavaFX Timeline to ensure execution on JavaFX Application Thread.
&nbsp;    ///
&nbsp;    /// You are probably interested in calling the [DebouncedRunnable#cancel()] methods
&nbsp;    /// when you clean up. Otherwise, there is a chance that this listener will run your
&nbsp;    /// methods after you removed it from all the properties that it is attached to.
&nbsp;    ///
&nbsp;    /// @param runnable the runnable to debounce
&nbsp;    /// @return a debounced runnable
&nbsp;    public static DebouncedRunnable debounced(Runnable runnable) {
<b class="nc">&nbsp;        return debounced(runnable, DEFAULT_DEBOUNCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Creates a debounced Runnable that limits execution to at most once per interval.
&nbsp;    /// Uses JavaFX Timeline to ensure execution on JavaFX Application Thread.
&nbsp;    ///
&nbsp;    /// You are probably interested in calling the [DebouncedRunnable#cancel()] methods
&nbsp;    /// when you clean up. Otherwise, there is a chance that this listener will run your
&nbsp;    /// methods after you removed it from all the properties that it is attached to.
&nbsp;    ///
&nbsp;    /// @param runnable   the runnable to debounce
&nbsp;    /// @param intervalMs the minimum interval between executions in milliseconds
&nbsp;    /// @return a debounced runnable
&nbsp;    public static DebouncedRunnable debounced(Runnable runnable, long intervalMs) {
<b class="nc">&nbsp;        Timeline timeline = new Timeline();</b>
<b class="nc">&nbsp;        return new DebouncedRunnable() {</b>
&nbsp;            @Override
&nbsp;            public void cancel() {
<b class="nc">&nbsp;                timeline.stop();</b>
<b class="nc">&nbsp;                timeline.getKeyFrames().clear();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void run() {
<b class="nc">&nbsp;                scheduleExecution(timeline, intervalMs, runnable);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private static void scheduleExecution(Timeline timeline, long intervalMs, Runnable action) {
<b class="nc">&nbsp;        timeline.stop();</b>
<b class="nc">&nbsp;        timeline.getKeyFrames().setAll(new KeyFrame(Duration.millis(intervalMs), _ -&gt; action.run()));</b>
<b class="nc">&nbsp;        timeline.play();</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Attaches a listener to the global window list that fires on every window change
&nbsp;    /// until a stop condition is met.
&nbsp;    ///
&nbsp;    /// @param stopCondition A supplier that should return true when the listener should
&nbsp;    ///                                           be detached (as well as run anything interesting for the
&nbsp;    ///                                           actual callee).
&nbsp;    /// @return A runnable that can be used to detach the listener prematurely.
&nbsp;    public static Runnable onWindowChangedUntil(@NonNull BooleanSupplier stopCondition) {
<b class="nc">&nbsp;        ListChangeListener&lt;Window&gt; listener = new ListChangeListener&lt;&gt;() {</b>
&nbsp;            @Override
&nbsp;            public void onChanged(Change&lt;? extends Window&gt; change) {
<b class="nc">&nbsp;                while (change.next()) {</b>
<b class="nc">&nbsp;                    if (change.wasAdded() || change.wasRemoved()) {</b>
<b class="nc">&nbsp;                        if (stopCondition.getAsBoolean()) {</b>
<b class="nc">&nbsp;                            Window.getWindows().removeListener(this);</b>
&nbsp;                            break;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        };
<b class="nc">&nbsp;        Window.getWindows().addListener(listener);</b>
<b class="nc">&nbsp;        return () -&gt; Window.getWindows().removeListener(listener);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
