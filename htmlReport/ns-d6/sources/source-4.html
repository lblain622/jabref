


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > GroupsParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.logic.importer.util</a>
</div>

<h1>Coverage Summary for Class: GroupsParser (org.jabref.logic.importer.util)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GroupsParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/144)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.logic.importer.util;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.EnumSet;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import org.jabref.logic.auxparser.DefaultAuxParser;
&nbsp;import org.jabref.logic.groups.DefaultGroupsFactory;
&nbsp;import org.jabref.logic.importer.ParseException;
&nbsp;import org.jabref.logic.l10n.Localization;
&nbsp;import org.jabref.logic.util.MetadataSerializationConfiguration;
&nbsp;import org.jabref.logic.util.strings.QuotedStringTokenizer;
&nbsp;import org.jabref.model.database.BibDatabase;
&nbsp;import org.jabref.model.entry.field.Field;
&nbsp;import org.jabref.model.entry.field.FieldFactory;
&nbsp;import org.jabref.model.groups.AbstractGroup;
&nbsp;import org.jabref.model.groups.AutomaticKeywordGroup;
&nbsp;import org.jabref.model.groups.AutomaticPersonsGroup;
&nbsp;import org.jabref.model.groups.ExplicitGroup;
&nbsp;import org.jabref.model.groups.GroupHierarchyType;
&nbsp;import org.jabref.model.groups.GroupTreeNode;
&nbsp;import org.jabref.model.groups.KeywordGroup;
&nbsp;import org.jabref.model.groups.RegexKeywordGroup;
&nbsp;import org.jabref.model.groups.SearchGroup;
&nbsp;import org.jabref.model.groups.SmartGroup;
&nbsp;import org.jabref.model.groups.TexGroup;
&nbsp;import org.jabref.model.groups.WordKeywordGroup;
&nbsp;import org.jabref.model.metadata.MetaData;
&nbsp;import org.jabref.model.search.SearchFlags;
&nbsp;import org.jabref.model.strings.StringUtil;
&nbsp;import org.jabref.model.util.FileUpdateMonitor;
&nbsp;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * Converts string representation of groups to a parsed {@link GroupTreeNode}.
&nbsp; */
&nbsp;public class GroupsParser {
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(GroupsParser.class);</b>
&nbsp;
&nbsp;    private GroupsParser() {
&nbsp;    }
&nbsp;
&nbsp;    public static GroupTreeNode importGroups(List&lt;String&gt; orderedData, Character keywordSeparator, FileUpdateMonitor fileMonitor, MetaData metaData, String userAndHost)
&nbsp;            throws ParseException {
&nbsp;        try {
<b class="nc">&nbsp;            GroupTreeNode cursor = null;</b>
<b class="nc">&nbsp;            GroupTreeNode root = null;</b>
<b class="nc">&nbsp;            for (String string : orderedData) {</b>
&nbsp;                // This allows reading databases that have been modified by, e.g., BibDesk
<b class="nc">&nbsp;                string = string.trim();</b>
<b class="nc">&nbsp;                if (string.isEmpty()) {</b>
&nbsp;                    continue;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                int spaceIndex = string.indexOf(&#39; &#39;);</b>
<b class="nc">&nbsp;                if (spaceIndex &lt;= 0) {</b>
<b class="nc">&nbsp;                    throw new ParseException(&quot;Expected \&quot;&quot; + string + &quot;\&quot; to contain whitespace&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                int level = Integer.parseInt(string.substring(0, spaceIndex));</b>
<b class="nc">&nbsp;                AbstractGroup group = GroupsParser.fromString(string.substring(spaceIndex + 1), keywordSeparator, fileMonitor, metaData, userAndHost);</b>
<b class="nc">&nbsp;                GroupTreeNode newNode = GroupTreeNode.fromGroup(group);</b>
<b class="nc">&nbsp;                if (cursor == null) {</b>
&nbsp;                    // create new root
<b class="nc">&nbsp;                    cursor = newNode;</b>
<b class="nc">&nbsp;                    root = cursor;</b>
&nbsp;                } else {
&nbsp;                    // insert at desired location
<b class="nc">&nbsp;                    while ((level &lt;= cursor.getLevel()) &amp;&amp; (cursor.getParent().isPresent())) {</b>
<b class="nc">&nbsp;                        cursor = cursor.getParent().get();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    cursor.addChild(newNode);</b>
<b class="nc">&nbsp;                    cursor = newNode;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return root;</b>
&nbsp;        } catch (ParseException e) {
<b class="nc">&nbsp;            throw new ParseException(Localization</b>
<b class="nc">&nbsp;                    .lang(&quot;Group tree could not be parsed. If you save the BibTeX library, all groups will be lost.&quot;),</b>
&nbsp;                    e);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Re-create a group instance from a textual representation.
&nbsp;     *
&nbsp;     * @param s The result from the group&#39;s toString() method.
&nbsp;     * @return New instance of the encoded group.
&nbsp;     * @throws ParseException If an error occurred and a group could not be created, e.g. due to a malformed regular expression.
&nbsp;     */
&nbsp;    public static AbstractGroup fromString(String s, Character keywordSeparator, FileUpdateMonitor fileMonitor, MetaData metaData, String userAndHost)
&nbsp;            throws ParseException {
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.KEYWORD_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return keywordGroupFromString(s, keywordSeparator);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.ALL_ENTRIES_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return allEntriesGroupFromString(s);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.SMART_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return smartGroupFromString(s, keywordSeparator);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.SEARCH_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return searchGroupFromString(s);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.EXPLICIT_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return explicitGroupFromString(s, keywordSeparator);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.LEGACY_EXPLICIT_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return legacyExplicitGroupFromString(s, keywordSeparator);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.AUTOMATIC_PERSONS_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return automaticPersonsGroupFromString(s);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.AUTOMATIC_KEYWORD_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return automaticKeywordGroupFromString(s);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (s.startsWith(MetadataSerializationConfiguration.TEX_GROUP_ID)) {</b>
<b class="nc">&nbsp;            return texGroupFromString(s, fileMonitor, metaData, userAndHost);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        throw new ParseException(&quot;Unknown group: &quot; + s);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static AbstractGroup texGroupFromString(String string, FileUpdateMonitor fileMonitor, MetaData metaData, String userAndHost) throws ParseException {
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(string.substring(MetadataSerializationConfiguration.TEX_GROUP_ID</b>
<b class="nc">&nbsp;                .length()), MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;        GroupHierarchyType context = GroupHierarchyType.getByNumberOrDefault(Integer.parseInt(tok.nextToken()));</b>
&nbsp;        try {
<b class="nc">&nbsp;            Path path = Path.of(tok.nextToken());</b>
&nbsp;            try {
<b class="nc">&nbsp;                TexGroup newGroup = TexGroup.create(name, context, path, new DefaultAuxParser(new BibDatabase()), fileMonitor, metaData, userAndHost);</b>
<b class="nc">&nbsp;                addGroupDetails(tok, newGroup);</b>
<b class="nc">&nbsp;                return newGroup;</b>
&nbsp;            } catch (IOException ex) {
&nbsp;                // Problem accessing file -&gt; create without file monitoring
<b class="nc">&nbsp;                LOGGER.warn(&quot;Could not access file {}. The group {} will not reflect changes to the aux file.&quot;, path, name, ex);</b>
&nbsp;
<b class="nc">&nbsp;                TexGroup newGroup = TexGroup.create(name, context, path, new DefaultAuxParser(new BibDatabase()), metaData, userAndHost);</b>
<b class="nc">&nbsp;                addGroupDetails(tok, newGroup);</b>
<b class="nc">&nbsp;                return newGroup;</b>
&nbsp;            }
&nbsp;        } catch (InvalidPathException | IOException ex) {
<b class="nc">&nbsp;            throw new ParseException(ex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static AbstractGroup automaticPersonsGroupFromString(String string) {
<b class="nc">&nbsp;        if (!string.startsWith(MetadataSerializationConfiguration.AUTOMATIC_PERSONS_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;KeywordGroup cannot be created from \&quot;&quot; + string + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(string.substring(MetadataSerializationConfiguration.AUTOMATIC_PERSONS_GROUP_ID</b>
<b class="nc">&nbsp;                .length()), MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;        GroupHierarchyType context = GroupHierarchyType.getByNumberOrDefault(Integer.parseInt(tok.nextToken()));</b>
<b class="nc">&nbsp;        Field field = FieldFactory.parseField(StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR));</b>
<b class="nc">&nbsp;        AutomaticPersonsGroup newGroup = new AutomaticPersonsGroup(name, context, field);</b>
<b class="nc">&nbsp;        addGroupDetails(tok, newGroup);</b>
<b class="nc">&nbsp;        return newGroup;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static AbstractGroup automaticKeywordGroupFromString(String string) {
<b class="nc">&nbsp;        if (!string.startsWith(MetadataSerializationConfiguration.AUTOMATIC_KEYWORD_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;KeywordGroup cannot be created from \&quot;&quot; + string + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(string.substring(MetadataSerializationConfiguration.AUTOMATIC_KEYWORD_GROUP_ID</b>
<b class="nc">&nbsp;                .length()), MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;        GroupHierarchyType context = GroupHierarchyType.getByNumberOrDefault(Integer.parseInt(tok.nextToken()));</b>
<b class="nc">&nbsp;        Field field = FieldFactory.parseField(StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR));</b>
<b class="nc">&nbsp;        Character delimiter = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR).charAt(0);</b>
<b class="nc">&nbsp;        Character hierarchicalDelimiter = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR).charAt(0);</b>
<b class="nc">&nbsp;        AutomaticKeywordGroup newGroup = new AutomaticKeywordGroup(name, context, field, delimiter, hierarchicalDelimiter);</b>
<b class="nc">&nbsp;        addGroupDetails(tok, newGroup);</b>
<b class="nc">&nbsp;        return newGroup;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses s and recreates the KeywordGroup from it.
&nbsp;     *
&nbsp;     * @param s The String representation obtained from KeywordGroup.toString()
&nbsp;     */
&nbsp;    private static KeywordGroup keywordGroupFromString(String s, Character keywordSeparator) {
<b class="nc">&nbsp;        if (!s.startsWith(MetadataSerializationConfiguration.KEYWORD_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;KeywordGroup cannot be created from \&quot;&quot; + s + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(s.substring(MetadataSerializationConfiguration.KEYWORD_GROUP_ID</b>
<b class="nc">&nbsp;                .length()), MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;        GroupHierarchyType context = GroupHierarchyType.getByNumberOrDefault(Integer.parseInt(tok.nextToken()));</b>
<b class="nc">&nbsp;        Field field = FieldFactory.parseField(StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR));</b>
<b class="nc">&nbsp;        String expression = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;        boolean caseSensitive = Integer.parseInt(tok.nextToken()) == 1;</b>
<b class="nc">&nbsp;        boolean regExp = Integer.parseInt(tok.nextToken()) == 1;</b>
&nbsp;        KeywordGroup newGroup;
<b class="nc">&nbsp;        if (regExp) {</b>
<b class="nc">&nbsp;            newGroup = new RegexKeywordGroup(name, context, field, expression, caseSensitive);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            newGroup = new WordKeywordGroup(name, context, field, expression, caseSensitive, keywordSeparator, false);</b>
&nbsp;        }
<b class="nc">&nbsp;        addGroupDetails(tok, newGroup);</b>
<b class="nc">&nbsp;        return newGroup;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static SmartGroup smartGroupFromString(String input, Character keywordSeparator) throws ParseException {
<b class="nc">&nbsp;        if (!input.startsWith(MetadataSerializationConfiguration.SMART_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;SmartGroup cannot be created from \&quot;&quot; + input + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(input.substring(MetadataSerializationConfiguration.SMART_GROUP_ID.length()),</b>
&nbsp;                MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
&nbsp;        try {
<b class="nc">&nbsp;            int context = Integer.parseInt(tok.nextToken());</b>
<b class="nc">&nbsp;            SmartGroup newGroup = new SmartGroup(name, GroupHierarchyType.getByNumberOrDefault(context), keywordSeparator);</b>
<b class="nc">&nbsp;            addGroupDetails(tok, newGroup);</b>
<b class="nc">&nbsp;            return newGroup;</b>
&nbsp;        } catch (NumberFormatException exception) {
<b class="nc">&nbsp;            throw new ParseException(&quot;Could not parse context in &quot; + input);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static ExplicitGroup explicitGroupFromString(String input, Character keywordSeparator) throws ParseException {
<b class="nc">&nbsp;        if (!input.startsWith(MetadataSerializationConfiguration.EXPLICIT_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;ExplicitGroup cannot be created from \&quot;&quot; + input + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(input.substring(MetadataSerializationConfiguration.EXPLICIT_GROUP_ID.length()),</b>
&nbsp;                MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
&nbsp;        try {
<b class="nc">&nbsp;            int context = Integer.parseInt(tok.nextToken());</b>
<b class="nc">&nbsp;            ExplicitGroup newGroup = new ExplicitGroup(name, GroupHierarchyType.getByNumberOrDefault(context), keywordSeparator);</b>
<b class="nc">&nbsp;            addGroupDetails(tok, newGroup);</b>
<b class="nc">&nbsp;            return newGroup;</b>
&nbsp;        } catch (NumberFormatException exception) {
<b class="nc">&nbsp;            throw new ParseException(&quot;Could not parse context in &quot; + input);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static ExplicitGroup legacyExplicitGroupFromString(String input, Character keywordSeparator) throws ParseException {
<b class="nc">&nbsp;        if (!input.startsWith(MetadataSerializationConfiguration.LEGACY_EXPLICIT_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;ExplicitGroup cannot be created from \&quot;&quot; + input + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(input.substring(MetadataSerializationConfiguration.LEGACY_EXPLICIT_GROUP_ID.length()),</b>
&nbsp;                MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
&nbsp;        try {
<b class="nc">&nbsp;            int context = Integer.parseInt(tok.nextToken());</b>
<b class="nc">&nbsp;            ExplicitGroup newGroup = new ExplicitGroup(name, GroupHierarchyType.getByNumberOrDefault(context), keywordSeparator);</b>
<b class="nc">&nbsp;            GroupsParser.addLegacyEntryKeys(tok, newGroup);</b>
<b class="nc">&nbsp;            return newGroup;</b>
&nbsp;        } catch (NumberFormatException exception) {
<b class="nc">&nbsp;            throw new ParseException(&quot;Could not parse context in &quot; + input);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called only when created fromString.
&nbsp;     * JabRef used to store the entries of an explicit group in the serialization, e.g.
&nbsp;     * ExplicitGroup:GroupName\;0\;Key1\;Key2\;;
&nbsp;     * This method exists for backwards compatibility.
&nbsp;     */
&nbsp;    private static void addLegacyEntryKeys(QuotedStringTokenizer tok, ExplicitGroup group) {
<b class="nc">&nbsp;        while (tok.hasMoreTokens()) {</b>
<b class="nc">&nbsp;            String key = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;            group.addLegacyEntryKey(key);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static AbstractGroup allEntriesGroupFromString(String s) {
<b class="nc">&nbsp;        if (!s.startsWith(MetadataSerializationConfiguration.ALL_ENTRIES_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;AllEntriesGroup cannot be created from \&quot;&quot; + s + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return DefaultGroupsFactory.getAllEntriesGroup();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses s and recreates the SearchGroup from it.
&nbsp;     *
&nbsp;     * @param s The String representation obtained from SearchGroup.toString(), or null if incompatible
&nbsp;     */
&nbsp;    private static AbstractGroup searchGroupFromString(String s) {
<b class="nc">&nbsp;        if (!s.startsWith(MetadataSerializationConfiguration.SEARCH_GROUP_ID)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;SearchGroup cannot be created from \&quot;&quot; + s + &quot;\&quot;.&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        QuotedStringTokenizer tok = new QuotedStringTokenizer(s.substring(MetadataSerializationConfiguration.SEARCH_GROUP_ID.length()),</b>
&nbsp;                MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR, MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);
&nbsp;
<b class="nc">&nbsp;        String name = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;        int context = Integer.parseInt(tok.nextToken());</b>
<b class="nc">&nbsp;        String expression = StringUtil.unquote(tok.nextToken(), MetadataSerializationConfiguration.GROUP_QUOTE_CHAR);</b>
<b class="nc">&nbsp;        EnumSet&lt;SearchFlags&gt; searchFlags = EnumSet.noneOf(SearchFlags.class);</b>
<b class="nc">&nbsp;        if (Integer.parseInt(tok.nextToken()) == 1) {</b>
<b class="nc">&nbsp;            searchFlags.add(SearchFlags.CASE_SENSITIVE);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (Integer.parseInt(tok.nextToken()) == 1) {</b>
<b class="nc">&nbsp;            searchFlags.add(SearchFlags.REGULAR_EXPRESSION);</b>
&nbsp;        }
&nbsp;        // version 0 contained 4 additional booleans to specify search
&nbsp;        // fields; these are ignored now, all fields are always searched
<b class="nc">&nbsp;        SearchGroup searchGroup = new SearchGroup(name,</b>
<b class="nc">&nbsp;                GroupHierarchyType.getByNumberOrDefault(context), expression, searchFlags</b>
&nbsp;        );
<b class="nc">&nbsp;        addGroupDetails(tok, searchGroup);</b>
<b class="nc">&nbsp;        return searchGroup;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void addGroupDetails(QuotedStringTokenizer tokenizer, AbstractGroup group) {
<b class="nc">&nbsp;        if (tokenizer.hasMoreTokens()) {</b>
<b class="nc">&nbsp;            group.setExpanded(Integer.parseInt(tokenizer.nextToken()) == 1);</b>
<b class="nc">&nbsp;            group.setColor(tokenizer.nextToken());</b>
<b class="nc">&nbsp;            group.setIconName(tokenizer.nextToken());</b>
<b class="nc">&nbsp;            group.setDescription(tokenizer.nextToken());</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
