


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BackupManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.gui.autosaveandbackup</a>
</div>

<h1>Coverage Summary for Class: BackupManager (org.jabref.gui.autosaveandbackup)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BackupManager</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/116)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.gui.autosaveandbackup;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Writer;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.charset.StandardCharsets;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.StandardCopyOption;
&nbsp;import java.nio.file.attribute.FileTime;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Queue;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.BlockingQueue;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.LinkedBlockingQueue;
&nbsp;import java.util.concurrent.ScheduledThreadPoolExecutor;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;import javafx.scene.control.TableColumn;
&nbsp;
&nbsp;import org.jabref.gui.LibraryTab;
&nbsp;import org.jabref.gui.maintable.BibEntryTableViewModel;
&nbsp;import org.jabref.gui.maintable.columns.MainTableColumn;
&nbsp;import org.jabref.logic.bibtex.InvalidFieldValueException;
&nbsp;import org.jabref.logic.exporter.AtomicFileWriter;
&nbsp;import org.jabref.logic.exporter.BibDatabaseWriter;
&nbsp;import org.jabref.logic.exporter.BibWriter;
&nbsp;import org.jabref.logic.exporter.SelfContainedSaveConfiguration;
&nbsp;import org.jabref.logic.preferences.CliPreferences;
&nbsp;import org.jabref.logic.util.BackupFileType;
&nbsp;import org.jabref.logic.util.CoarseChangeFilter;
&nbsp;import org.jabref.logic.util.io.BackupFileUtil;
&nbsp;import org.jabref.model.database.BibDatabase;
&nbsp;import org.jabref.model.database.BibDatabaseContext;
&nbsp;import org.jabref.model.database.event.BibDatabaseContextChangedEvent;
&nbsp;import org.jabref.model.entry.BibEntry;
&nbsp;import org.jabref.model.entry.BibEntryTypesManager;
&nbsp;import org.jabref.model.entry.BibtexString;
&nbsp;import org.jabref.model.metadata.SaveOrder;
&nbsp;import org.jabref.model.metadata.SelfContainedSaveOrder;
&nbsp;
&nbsp;import com.google.common.eventbus.Subscribe;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * Backups the given bib database file from {@link BibDatabaseContext} on every {@link BibDatabaseContextChangedEvent}.
&nbsp; * An intelligent {@link ExecutorService} with a {@link BlockingQueue} prevents a high load while making backups and
&nbsp; * rejects all redundant backup tasks. This class does not manage the .bak file which is created when opening a
&nbsp; * database.
&nbsp; */
&nbsp;public class BackupManager {
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(BackupManager.class);</b>
&nbsp;
&nbsp;    private static final int MAXIMUM_BACKUP_FILE_COUNT = 10;
&nbsp;
&nbsp;    private static final int DELAY_BETWEEN_BACKUP_ATTEMPTS_IN_SECONDS = 19;
&nbsp;
<b class="nc">&nbsp;    private static final Set&lt;BackupManager&gt; RUNNING_INSTANCES = new HashSet&lt;&gt;();</b>
&nbsp;
&nbsp;    private final BibDatabaseContext bibDatabaseContext;
&nbsp;    private final CoarseChangeFilter coarseChangeFilter;
&nbsp;    private final CliPreferences preferences;
&nbsp;    private final ScheduledThreadPoolExecutor executor;
&nbsp;    private final BibEntryTypesManager entryTypesManager;
&nbsp;    private final LibraryTab libraryTab;
&nbsp;
&nbsp;    // Contains a list of all backup paths
&nbsp;    // During writing, the less recent backup file is deleted
<b class="nc">&nbsp;    private final Queue&lt;Path&gt; backupFilesQueue = new LinkedBlockingQueue&lt;&gt;();</b>
<b class="nc">&nbsp;    private boolean needsBackup = false;</b>
&nbsp;
<b class="nc">&nbsp;    BackupManager(LibraryTab libraryTab, BibDatabaseContext bibDatabaseContext, CoarseChangeFilter coarseChangeFilter, BibEntryTypesManager entryTypesManager, CliPreferences preferences) {</b>
<b class="nc">&nbsp;        this.bibDatabaseContext = bibDatabaseContext;</b>
<b class="nc">&nbsp;        this.coarseChangeFilter = coarseChangeFilter;</b>
<b class="nc">&nbsp;        this.entryTypesManager = entryTypesManager;</b>
<b class="nc">&nbsp;        this.preferences = preferences;</b>
<b class="nc">&nbsp;        this.executor = new ScheduledThreadPoolExecutor(2);</b>
<b class="nc">&nbsp;        this.libraryTab = libraryTab;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the most recent backup file name
&nbsp;     */
&nbsp;    static Path getBackupPathForNewBackup(Path originalPath, Path backupDir) {
<b class="nc">&nbsp;        return BackupFileUtil.getPathForNewBackupFileAndCreateDirectory(originalPath, BackupFileType.BACKUP, backupDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the most recent existing backup file name
&nbsp;     */
&nbsp;    static Optional&lt;Path&gt; getLatestBackupPath(Path originalPath, Path backupDir) {
<b class="nc">&nbsp;        return BackupFileUtil.getPathOfLatestExistingBackupFile(originalPath, BackupFileType.BACKUP, backupDir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Starts the BackupManager which is associated with the given {@link BibDatabaseContext}. As long as no database
&nbsp;     * file is present in {@link BibDatabaseContext}, the {@link BackupManager} will do nothing.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method is not thread-safe. The caller has to ensure that this method is not called in parallel.
&nbsp;     *
&nbsp;     * @param bibDatabaseContext Associated {@link BibDatabaseContext}
&nbsp;     */
&nbsp;    public static BackupManager start(LibraryTab libraryTab, BibDatabaseContext bibDatabaseContext, CoarseChangeFilter coarseChangeFilter, BibEntryTypesManager entryTypesManager, CliPreferences preferences) {
<b class="nc">&nbsp;        BackupManager backupManager = new BackupManager(libraryTab, bibDatabaseContext, coarseChangeFilter, entryTypesManager, preferences);</b>
<b class="nc">&nbsp;        backupManager.startBackupTask(preferences.getFilePreferences().getBackupDirectory());</b>
<b class="nc">&nbsp;        coarseChangeFilter.registerListener(backupManager);</b>
<b class="nc">&nbsp;        RUNNING_INSTANCES.add(backupManager);</b>
<b class="nc">&nbsp;        return backupManager;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks the backup as discarded at the library which is associated with the given {@link BibDatabaseContext}.
&nbsp;     *
&nbsp;     * @param bibDatabaseContext Associated {@link BibDatabaseContext}
&nbsp;     */
&nbsp;    public static void discardBackup(BibDatabaseContext bibDatabaseContext, Path backupDir) {
<b class="nc">&nbsp;        RUNNING_INSTANCES.stream().filter(instance -&gt; instance.bibDatabaseContext == bibDatabaseContext).forEach(backupManager -&gt; backupManager.discardBackup(backupDir));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Shuts down the BackupManager which is associated with the given {@link BibDatabaseContext}.
&nbsp;     *
&nbsp;     * @param bibDatabaseContext Associated {@link BibDatabaseContext}
&nbsp;     * @param backupDir          The path to the backup directory
&nbsp;     * @param createBackup       True, if a backup should be created
&nbsp;     */
&nbsp;    public static void shutdown(BibDatabaseContext bibDatabaseContext, Path backupDir, boolean createBackup) {
<b class="nc">&nbsp;        RUNNING_INSTANCES.stream().filter(instance -&gt; instance.bibDatabaseContext == bibDatabaseContext).forEach(backupManager -&gt; backupManager.shutdown(backupDir, createBackup));</b>
<b class="nc">&nbsp;        RUNNING_INSTANCES.removeIf(instance -&gt; instance.bibDatabaseContext == bibDatabaseContext);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks whether a backup file exists for the given database file. If it exists, it is checked whether it is
&nbsp;     * newer and different from the original.
&nbsp;     * &lt;p&gt;
&nbsp;     * In case a discarded file is present, the method also returns &lt;code&gt;false&lt;/code&gt;, See also {@link #discardBackup(Path)}.
&nbsp;     *
&nbsp;     * @param originalPath Path to the file a backup should be checked for. Example: jabref.bib.
&nbsp;     * @return &lt;code&gt;true&lt;/code&gt; if backup file exists AND differs from originalPath. &lt;code&gt;false&lt;/code&gt; is the
&nbsp;     * &quot;default&quot; return value in the good case. In case a discarded file exists, &lt;code&gt;false&lt;/code&gt; is returned, too.
&nbsp;     * In the case of an exception &lt;code&gt;true&lt;/code&gt; is returned to ensure that the user checks the output.
&nbsp;     */
&nbsp;    public static boolean backupFileDiffers(Path originalPath, Path backupDir) {
<b class="nc">&nbsp;        Path discardedFile = determineDiscardedFile(originalPath, backupDir);</b>
<b class="nc">&nbsp;        if (Files.exists(discardedFile)) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                Files.delete(discardedFile);</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                LOGGER.error(&quot;Could not remove discarded file {}&quot;, discardedFile, e);</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        return getLatestBackupPath(originalPath, backupDir).map(latestBackupPath -&gt; {</b>
&nbsp;            FileTime latestBackupFileLastModifiedTime;
&nbsp;            try {
<b class="nc">&nbsp;                latestBackupFileLastModifiedTime = Files.getLastModifiedTime(latestBackupPath);</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                LOGGER.debug(&quot;Could not get timestamp of backup file {}&quot;, latestBackupPath, e);</b>
&nbsp;                // If we cannot get the timestamp, we do show any warning
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            FileTime currentFileLastModifiedTime;
&nbsp;            try {
<b class="nc">&nbsp;                currentFileLastModifiedTime = Files.getLastModifiedTime(originalPath);</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                LOGGER.debug(&quot;Could not get timestamp of current file file {}&quot;, originalPath, e);</b>
&nbsp;                // If we cannot get the timestamp, we do show any warning
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (latestBackupFileLastModifiedTime.compareTo(currentFileLastModifiedTime) &lt;= 0) {</b>
&nbsp;                // Backup is older than current file
&nbsp;                // We treat the backup as non-different (even if it could differ)
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                boolean result = Files.mismatch(originalPath, latestBackupPath) != -1L;</b>
<b class="nc">&nbsp;                if (result) {</b>
<b class="nc">&nbsp;                    LOGGER.info(&quot;Backup file {} differs from current file {}&quot;, latestBackupPath, originalPath);</b>
&nbsp;                }
<b class="nc">&nbsp;                return result;</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                LOGGER.debug(&quot;Could not compare original file and backup file.&quot;, e);</b>
&nbsp;                // User has to investigate in this case
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;        }).orElse(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Restores the backup file by copying and overwriting the original one.
&nbsp;     *
&nbsp;     * @param originalPath Path to the file which should be equalized to the backup file.
&nbsp;     */
&nbsp;    public static void restoreBackup(Path originalPath, Path backupDir) {
<b class="nc">&nbsp;        Optional&lt;Path&gt; backupPath = getLatestBackupPath(originalPath, backupDir);</b>
<b class="nc">&nbsp;        if (backupPath.isEmpty()) {</b>
<b class="nc">&nbsp;            LOGGER.error(&quot;There is no backup file&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            Files.copy(backupPath.get(), originalPath, StandardCopyOption.REPLACE_EXISTING);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Error while restoring the backup file.&quot;, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    Optional&lt;Path&gt; determineBackupPathForNewBackup(Path backupDir) {
<b class="nc">&nbsp;        return bibDatabaseContext.getDatabasePath().map(path -&gt; BackupManager.getBackupPathForNewBackup(path, backupDir));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method is called as soon as the scheduler says: &quot;Do the backup&quot;
&nbsp;     *
&nbsp;     * &lt;em&gt;SIDE EFFECT: Deletes oldest backup file&lt;/em&gt;
&nbsp;     *
&nbsp;     * @param backupPath the full path to the file where the library should be backed up to
&nbsp;     */
&nbsp;    void performBackup(Path backupPath) {
<b class="nc">&nbsp;        if (!needsBackup) {</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
&nbsp;        // We opted for &quot;while&quot; to delete backups in case there are more than 10
<b class="nc">&nbsp;        while (backupFilesQueue.size() &gt;= MAXIMUM_BACKUP_FILE_COUNT) {</b>
<b class="nc">&nbsp;            Path oldestBackupFile = backupFilesQueue.poll();</b>
&nbsp;            try {
<b class="nc">&nbsp;                Files.delete(oldestBackupFile);</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                LOGGER.error(&quot;Could not delete backup file {}&quot;, oldestBackupFile, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // code similar to org.jabref.gui.exporter.SaveDatabaseAction.saveDatabase
<b class="nc">&nbsp;        SelfContainedSaveOrder saveOrder = bibDatabaseContext</b>
<b class="nc">&nbsp;                .getMetaData().getSaveOrder()</b>
<b class="nc">&nbsp;                .map(so -&gt; {</b>
<b class="nc">&nbsp;                    if (so.getOrderType() == SaveOrder.OrderType.TABLE) {</b>
&nbsp;                        // We need to &quot;flatten out&quot; SaveOrder.OrderType.TABLE as BibWriter does not have access to preferences
<b class="nc">&nbsp;                        List&lt;TableColumn&lt;BibEntryTableViewModel, ?&gt;&gt; sortOrder = libraryTab.getMainTable().getSortOrder();</b>
<b class="nc">&nbsp;                        return new SelfContainedSaveOrder(</b>
&nbsp;                                SaveOrder.OrderType.SPECIFIED,
<b class="nc">&nbsp;                                sortOrder.stream()</b>
<b class="nc">&nbsp;                                         .filter(col -&gt; col instanceof MainTableColumn&lt;?&gt;)</b>
<b class="nc">&nbsp;                                         .map(column -&gt; ((MainTableColumn&lt;?&gt;) column).getModel())</b>
<b class="nc">&nbsp;                                         .flatMap(model -&gt; model.getSortCriteria().stream())</b>
<b class="nc">&nbsp;                                         .toList());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return SelfContainedSaveOrder.of(so);</b>
&nbsp;                    }
&nbsp;                })
<b class="nc">&nbsp;                .orElse(SaveOrder.getDefaultSaveOrder());</b>
<b class="nc">&nbsp;        SelfContainedSaveConfiguration saveConfiguration = (SelfContainedSaveConfiguration) new SelfContainedSaveConfiguration()</b>
<b class="nc">&nbsp;                .withMakeBackup(false)</b>
<b class="nc">&nbsp;                .withSaveOrder(saveOrder)</b>
<b class="nc">&nbsp;                .withReformatOnSave(preferences.getLibraryPreferences().shouldAlwaysReformatOnSave());</b>
&nbsp;
&nbsp;        // &quot;Clone&quot; the database context
&nbsp;        // We &quot;know&quot; that &quot;only&quot; the BibEntries might be changed during writing (see [org.jabref.logic.exporter.BibDatabaseWriter.savePartOfDatabase])
<b class="nc">&nbsp;        List&lt;BibEntry&gt; list = bibDatabaseContext.getDatabase().getEntries().stream()</b>
<b class="nc">&nbsp;                                                .map(BibEntry::new)</b>
<b class="nc">&nbsp;                                                .toList();</b>
<b class="nc">&nbsp;        BibDatabase bibDatabaseClone = new BibDatabase(list);</b>
<b class="nc">&nbsp;        bibDatabaseContext.getDatabase().getStringValues().stream().map(BibtexString::clone)</b>
<b class="nc">&nbsp;                          .map(BibtexString.class::cast)</b>
<b class="nc">&nbsp;                          .forEach(bibDatabaseClone::addString);</b>
<b class="nc">&nbsp;        BibDatabaseContext bibDatabaseContextClone = new BibDatabaseContext(bibDatabaseClone, bibDatabaseContext.getMetaData());</b>
&nbsp;
<b class="nc">&nbsp;        Charset encoding = bibDatabaseContext.getMetaData().getEncoding().orElse(StandardCharsets.UTF_8);</b>
&nbsp;        // We want to have successful backups only
&nbsp;        // Thus, we do not use a plain &quot;FileWriter&quot;, but the &quot;AtomicFileWriter&quot;
&nbsp;        // Example: What happens if one hard powers off the machine (or kills the jabref process) during writing of the backup?
&nbsp;        //          This MUST NOT create a broken backup file that then jabref wants to &quot;restore&quot; from?
<b class="nc">&nbsp;        try (Writer writer = new AtomicFileWriter(backupPath, encoding, false)) {</b>
<b class="nc">&nbsp;            BibWriter bibWriter = new BibWriter(writer, bibDatabaseContext.getDatabase().getNewLineSeparator());</b>
<b class="nc">&nbsp;            new BibDatabaseWriter(</b>
&nbsp;                    bibWriter,
&nbsp;                    saveConfiguration,
<b class="nc">&nbsp;                    preferences.getFieldPreferences(),</b>
<b class="nc">&nbsp;                    preferences.getCitationKeyPatternPreferences(),</b>
&nbsp;                    entryTypesManager)
&nbsp;                    // we save the clone to prevent the original database (and thus the UI) from being changed
<b class="nc">&nbsp;                    .saveDatabase(bibDatabaseContextClone);</b>
<b class="nc">&nbsp;            backupFilesQueue.add(backupPath);</b>
&nbsp;
&nbsp;            // We wrote the file successfully
&nbsp;            // Thus, we currently do not need any new backup
<b class="nc">&nbsp;            this.needsBackup = false;</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            logIfCritical(backupPath, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Path determineDiscardedFile(Path file, Path backupDir) {
<b class="nc">&nbsp;        return backupDir.resolve(BackupFileUtil.getUniqueFilePrefix(file) + &quot;--&quot; + file.getFileName() + &quot;--discarded&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Marks the backups as discarded.
&nbsp;     * &lt;p&gt;
&nbsp;     * We do not delete any files, because the user might want to recover old backup files.
&nbsp;     * Therefore, we mark discarded backups by a --discarded file.
&nbsp;     */
&nbsp;    public void discardBackup(Path backupDir) {
<b class="nc">&nbsp;        Path path = determineDiscardedFile(bibDatabaseContext.getDatabasePath().get(), backupDir);</b>
&nbsp;        try {
<b class="nc">&nbsp;            Files.createFile(path);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            LOGGER.info(&quot;Could not create backup file {}&quot;, path, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void logIfCritical(Path backupPath, IOException e) {
<b class="nc">&nbsp;        Throwable innermostCause = e;</b>
<b class="nc">&nbsp;        while (innermostCause.getCause() != null) {</b>
<b class="nc">&nbsp;            innermostCause = innermostCause.getCause();</b>
&nbsp;        }
<b class="nc">&nbsp;        boolean isErrorInField = innermostCause instanceof InvalidFieldValueException;</b>
&nbsp;
&nbsp;        // do not print errors in field values into the log during autosave
<b class="nc">&nbsp;        if (!isErrorInField) {</b>
<b class="nc">&nbsp;            LOGGER.error(&quot;Error while saving to file {}&quot;, backupPath, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Subscribe
&nbsp;    public synchronized void listen(@SuppressWarnings(&quot;unused&quot;) BibDatabaseContextChangedEvent event) {
<b class="nc">&nbsp;        if (!event.isFilteredOut()) {</b>
<b class="nc">&nbsp;            this.needsBackup = true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void startBackupTask(Path backupDir) {
<b class="nc">&nbsp;        fillQueue(backupDir);</b>
&nbsp;
<b class="nc">&nbsp;        executor.scheduleAtFixedRate(</b>
&nbsp;                // We need to determine the backup path on each action, because we use the timestamp in the filename
<b class="nc">&nbsp;                () -&gt; determineBackupPathForNewBackup(backupDir).ifPresent(this::performBackup),</b>
&nbsp;                DELAY_BETWEEN_BACKUP_ATTEMPTS_IN_SECONDS,
&nbsp;                DELAY_BETWEEN_BACKUP_ATTEMPTS_IN_SECONDS,
&nbsp;                TimeUnit.SECONDS);
&nbsp;    }
&nbsp;
&nbsp;    private void fillQueue(Path backupDir) {
<b class="nc">&nbsp;        if (!Files.exists(backupDir)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        bibDatabaseContext.getDatabasePath().ifPresent(databasePath -&gt; {</b>
&nbsp;            // code similar to {@link org.jabref.logic.util.io.BackupFileUtil.getPathOfLatestExisingBackupFile}
<b class="nc">&nbsp;            final String prefix = BackupFileUtil.getUniqueFilePrefix(databasePath) + &quot;--&quot; + databasePath.getFileName();</b>
&nbsp;            try {
<b class="nc">&nbsp;                List&lt;Path&gt; allSavFiles = Files.list(backupDir)</b>
&nbsp;                                              // just list the .sav belonging to the given targetFile
<b class="nc">&nbsp;                                              .filter(p -&gt; p.getFileName().toString().startsWith(prefix))</b>
<b class="nc">&nbsp;                                              .sorted().toList();</b>
<b class="nc">&nbsp;                backupFilesQueue.addAll(allSavFiles);</b>
&nbsp;            } catch (IOException e) {
<b class="nc">&nbsp;                LOGGER.error(&quot;Could not determine most recent file&quot;, e);</b>
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Unregisters the BackupManager from the eventBus of {@link BibDatabaseContext}.
&nbsp;     * This method should only be used when closing a database/JabRef in a normal way.
&nbsp;     *
&nbsp;     * @param backupDir    The backup directory
&nbsp;     * @param createBackup If the backup manager should still perform a backup
&nbsp;     */
&nbsp;    private void shutdown(Path backupDir, boolean createBackup) {
<b class="nc">&nbsp;        coarseChangeFilter.unregisterListener(this);</b>
<b class="nc">&nbsp;        executor.shutdown();</b>
&nbsp;
<b class="nc">&nbsp;        if (createBackup) {</b>
&nbsp;            // Ensure that backup is a recent one
<b class="nc">&nbsp;            determineBackupPathForNewBackup(backupDir).ifPresent(this::performBackup);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
