


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > SearchParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.search</a>
</div>

<h1>Coverage Summary for Class: SearchParser (org.jabref.search)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SearchParser</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/193)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SearchParser$AndExpressionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$BinaryExpressionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$ComparisonContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$ComparisonExpressionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$ExpressionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$ImplicitAndExpressionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$NegatedExpressionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$OperatorContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$ParenExpressionContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$SearchValueContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SearchParser$StartContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/102)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/108)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/284)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// Generated from org/jabref/search/Search.g4 by ANTLR 4.13.2
&nbsp;
&nbsp;package org.jabref.search;
&nbsp;
&nbsp;import org.antlr.v4.runtime.atn.*;
&nbsp;import org.antlr.v4.runtime.dfa.DFA;
&nbsp;import org.antlr.v4.runtime.*;
&nbsp;import org.antlr.v4.runtime.misc.*;
&nbsp;import org.antlr.v4.runtime.tree.*;
&nbsp;import java.util.List;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.ArrayList;
&nbsp;
&nbsp;@SuppressWarnings({&quot;all&quot;, &quot;warnings&quot;, &quot;unchecked&quot;, &quot;unused&quot;, &quot;cast&quot;, &quot;CheckReturnValue&quot;, &quot;this-escape&quot;})
&nbsp;public class SearchParser extends Parser {
<b class="nc">&nbsp;	static { RuntimeMetaData.checkVersion(&quot;4.13.2&quot;, RuntimeMetaData.VERSION); }</b>
&nbsp;
&nbsp;	protected static final DFA[] _decisionToDFA;
<b class="nc">&nbsp;	protected static final PredictionContextCache _sharedContextCache =</b>
&nbsp;		new PredictionContextCache();
&nbsp;	public static final int
&nbsp;		WS=1, LPAREN=2, RPAREN=3, EQUAL=4, CEQUAL=5, EEQUAL=6, CEEQUAL=7, REQUAL=8, 
&nbsp;		CREEQUAL=9, NEQUAL=10, NCEQUAL=11, NEEQUAL=12, NCEEQUAL=13, NREQUAL=14, 
&nbsp;		NCREEQUAL=15, AND=16, OR=17, CONTAINS=18, MATCHES=19, NOT=20, FIELD=21, 
&nbsp;		STRING_LITERAL=22, TERM=23;
&nbsp;	public static final int
&nbsp;		RULE_start = 0, RULE_andExpression = 1, RULE_expression = 2, RULE_comparison = 3, 
&nbsp;		RULE_operator = 4, RULE_searchValue = 5;
&nbsp;	private static String[] makeRuleNames() {
<b class="nc">&nbsp;		return new String[] {</b>
&nbsp;			&quot;start&quot;, &quot;andExpression&quot;, &quot;expression&quot;, &quot;comparison&quot;, &quot;operator&quot;, &quot;searchValue&quot;
&nbsp;		};
&nbsp;	}
<b class="nc">&nbsp;	public static final String[] ruleNames = makeRuleNames();</b>
&nbsp;
&nbsp;	private static String[] makeLiteralNames() {
<b class="nc">&nbsp;		return new String[] {</b>
&nbsp;			null, null, &quot;&#39;(&#39;&quot;, &quot;&#39;)&#39;&quot;, &quot;&#39;=&#39;&quot;, &quot;&#39;=!&#39;&quot;, &quot;&#39;==&#39;&quot;, &quot;&#39;==!&#39;&quot;, &quot;&#39;=~&#39;&quot;, &quot;&#39;=~!&#39;&quot;, 
&nbsp;			&quot;&#39;!=&#39;&quot;, &quot;&#39;!=!&#39;&quot;, &quot;&#39;!==&#39;&quot;, &quot;&#39;!==!&#39;&quot;, &quot;&#39;!=~&#39;&quot;, &quot;&#39;!=~!&#39;&quot;, &quot;&#39;AND&#39;&quot;, &quot;&#39;OR&#39;&quot;, 
&nbsp;			&quot;&#39;CONTAINS&#39;&quot;, &quot;&#39;MATCHES&#39;&quot;, &quot;&#39;NOT&#39;&quot;
&nbsp;		};
&nbsp;	}
<b class="nc">&nbsp;	private static final String[] _LITERAL_NAMES = makeLiteralNames();</b>
&nbsp;	private static String[] makeSymbolicNames() {
<b class="nc">&nbsp;		return new String[] {</b>
&nbsp;			null, &quot;WS&quot;, &quot;LPAREN&quot;, &quot;RPAREN&quot;, &quot;EQUAL&quot;, &quot;CEQUAL&quot;, &quot;EEQUAL&quot;, &quot;CEEQUAL&quot;, 
&nbsp;			&quot;REQUAL&quot;, &quot;CREEQUAL&quot;, &quot;NEQUAL&quot;, &quot;NCEQUAL&quot;, &quot;NEEQUAL&quot;, &quot;NCEEQUAL&quot;, &quot;NREQUAL&quot;, 
&nbsp;			&quot;NCREEQUAL&quot;, &quot;AND&quot;, &quot;OR&quot;, &quot;CONTAINS&quot;, &quot;MATCHES&quot;, &quot;NOT&quot;, &quot;FIELD&quot;, &quot;STRING_LITERAL&quot;, 
&nbsp;			&quot;TERM&quot;
&nbsp;		};
&nbsp;	}
<b class="nc">&nbsp;	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();</b>
<b class="nc">&nbsp;	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * @deprecated Use {@link #VOCABULARY} instead.
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	public static final String[] tokenNames;
&nbsp;	static {
<b class="nc">&nbsp;		tokenNames = new String[_SYMBOLIC_NAMES.length];</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; tokenNames.length; i++) {</b>
<b class="nc">&nbsp;			tokenNames[i] = VOCABULARY.getLiteralName(i);</b>
<b class="nc">&nbsp;			if (tokenNames[i] == null) {</b>
<b class="nc">&nbsp;				tokenNames[i] = VOCABULARY.getSymbolicName(i);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (tokenNames[i] == null) {</b>
<b class="nc">&nbsp;				tokenNames[i] = &quot;&lt;INVALID&gt;&quot;;</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	@Deprecated
&nbsp;	public String[] getTokenNames() {
<b class="nc">&nbsp;		return tokenNames;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;
&nbsp;	public Vocabulary getVocabulary() {
<b class="nc">&nbsp;		return VOCABULARY;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
<b class="nc">&nbsp;	public String getGrammarFileName() { return &quot;Search.g4&quot;; }</b>
&nbsp;
&nbsp;	@Override
<b class="nc">&nbsp;	public String[] getRuleNames() { return ruleNames; }</b>
&nbsp;
&nbsp;	@Override
<b class="nc">&nbsp;	public String getSerializedATN() { return _serializedATN; }</b>
&nbsp;
&nbsp;	@Override
<b class="nc">&nbsp;	public ATN getATN() { return _ATN; }</b>
&nbsp;
&nbsp;	public SearchParser(TokenStream input) {
<b class="nc">&nbsp;		super(input);</b>
<b class="nc">&nbsp;		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class StartContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode EOF() { return getToken(SearchParser.EOF, 0); }</b>
&nbsp;		public AndExpressionContext andExpression() {
<b class="nc">&nbsp;			return getRuleContext(AndExpressionContext.class,0);</b>
&nbsp;		}
&nbsp;		public StartContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_start; }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterStart(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitStart(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitStart(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final StartContext start() throws RecognitionException {
<b class="nc">&nbsp;		StartContext _localctx = new StartContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 0, RULE_start);</b>
&nbsp;		try {
<b class="nc">&nbsp;			setState(16);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			switch (_input.LA(1)) {</b>
&nbsp;			case EOF:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 1);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(12);</b>
<b class="nc">&nbsp;				match(EOF);</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			case LPAREN:
&nbsp;			case NOT:
&nbsp;			case FIELD:
&nbsp;			case STRING_LITERAL:
&nbsp;			case TERM:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 2);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(13);</b>
<b class="nc">&nbsp;				andExpression();</b>
<b class="nc">&nbsp;				setState(14);</b>
<b class="nc">&nbsp;				match(EOF);</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			default:
<b class="nc">&nbsp;				throw new NoViableAltException(this);</b>
&nbsp;			}
&nbsp;		}
&nbsp;		catch (RecognitionException re) {
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
&nbsp;		}
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class AndExpressionContext extends ParserRuleContext {
&nbsp;		public AndExpressionContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_andExpression; }</b>
&nbsp;	 
<b class="nc">&nbsp;		public AndExpressionContext() { }</b>
&nbsp;		public void copyFrom(AndExpressionContext ctx) {
<b class="nc">&nbsp;			super.copyFrom(ctx);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ImplicitAndExpressionContext extends AndExpressionContext {
&nbsp;		public List&lt;ExpressionContext&gt; expression() {
<b class="nc">&nbsp;			return getRuleContexts(ExpressionContext.class);</b>
&nbsp;		}
&nbsp;		public ExpressionContext expression(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExpressionContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public ImplicitAndExpressionContext(AndExpressionContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterImplicitAndExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitImplicitAndExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitImplicitAndExpression(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final AndExpressionContext andExpression() throws RecognitionException {
<b class="nc">&nbsp;		AndExpressionContext _localctx = new AndExpressionContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 2, RULE_andExpression);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="nc">&nbsp;			_localctx = new ImplicitAndExpressionContext(_localctx);</b>
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(19); </b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
&nbsp;			do {
&nbsp;				{
&nbsp;				{
<b class="nc">&nbsp;				setState(18);</b>
<b class="nc">&nbsp;				expression(0);</b>
&nbsp;				}
&nbsp;				}
<b class="nc">&nbsp;				setState(21); </b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_la = _input.LA(1);</b>
<b class="nc">&nbsp;			} while ( (((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 15728644L) != 0) );</b>
&nbsp;			}
&nbsp;		}
&nbsp;		catch (RecognitionException re) {
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
&nbsp;		}
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ExpressionContext extends ParserRuleContext {
&nbsp;		public ExpressionContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_expression; }</b>
&nbsp;	 
<b class="nc">&nbsp;		public ExpressionContext() { }</b>
&nbsp;		public void copyFrom(ExpressionContext ctx) {
<b class="nc">&nbsp;			super.copyFrom(ctx);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class BinaryExpressionContext extends ExpressionContext {
&nbsp;		public ExpressionContext left;
&nbsp;		public Token bin_op;
&nbsp;		public ExpressionContext right;
&nbsp;		public List&lt;ExpressionContext&gt; expression() {
<b class="nc">&nbsp;			return getRuleContexts(ExpressionContext.class);</b>
&nbsp;		}
&nbsp;		public ExpressionContext expression(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExpressionContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode AND() { return getToken(SearchParser.AND, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode OR() { return getToken(SearchParser.OR, 0); }</b>
<b class="nc">&nbsp;		public BinaryExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterBinaryExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitBinaryExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitBinaryExpression(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class NegatedExpressionContext extends ExpressionContext {
<b class="nc">&nbsp;		public TerminalNode NOT() { return getToken(SearchParser.NOT, 0); }</b>
&nbsp;		public ExpressionContext expression() {
<b class="nc">&nbsp;			return getRuleContext(ExpressionContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public NegatedExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterNegatedExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitNegatedExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitNegatedExpression(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ComparisonExpressionContext extends ExpressionContext {
&nbsp;		public ComparisonContext comparison() {
<b class="nc">&nbsp;			return getRuleContext(ComparisonContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public ComparisonExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterComparisonExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitComparisonExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitComparisonExpression(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ParenExpressionContext extends ExpressionContext {
<b class="nc">&nbsp;		public TerminalNode LPAREN() { return getToken(SearchParser.LPAREN, 0); }</b>
&nbsp;		public AndExpressionContext andExpression() {
<b class="nc">&nbsp;			return getRuleContext(AndExpressionContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode RPAREN() { return getToken(SearchParser.RPAREN, 0); }</b>
<b class="nc">&nbsp;		public ParenExpressionContext(ExpressionContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterParenExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitParenExpression(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitParenExpression(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final ExpressionContext expression() throws RecognitionException {
<b class="nc">&nbsp;		return expression(0);</b>
&nbsp;	}
&nbsp;
&nbsp;	private ExpressionContext expression(int _p) throws RecognitionException {
<b class="nc">&nbsp;		ParserRuleContext _parentctx = _ctx;</b>
<b class="nc">&nbsp;		int _parentState = getState();</b>
<b class="nc">&nbsp;		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);</b>
<b class="nc">&nbsp;		ExpressionContext _prevctx = _localctx;</b>
<b class="nc">&nbsp;		int _startState = 4;</b>
<b class="nc">&nbsp;		enterRecursionRule(_localctx, 4, RULE_expression, _p);</b>
&nbsp;		try {
&nbsp;			int _alt;
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(31);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			switch (_input.LA(1)) {</b>
&nbsp;			case LPAREN:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new ParenExpressionContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
&nbsp;
<b class="nc">&nbsp;				setState(24);</b>
<b class="nc">&nbsp;				match(LPAREN);</b>
<b class="nc">&nbsp;				setState(25);</b>
<b class="nc">&nbsp;				andExpression();</b>
<b class="nc">&nbsp;				setState(26);</b>
<b class="nc">&nbsp;				match(RPAREN);</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			case NOT:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new NegatedExpressionContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(28);</b>
<b class="nc">&nbsp;				match(NOT);</b>
<b class="nc">&nbsp;				setState(29);</b>
<b class="nc">&nbsp;				expression(4);</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			case FIELD:
&nbsp;			case STRING_LITERAL:
&nbsp;			case TERM:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new ComparisonExpressionContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(30);</b>
<b class="nc">&nbsp;				comparison();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			default:
<b class="nc">&nbsp;				throw new NoViableAltException(this);</b>
&nbsp;			}
<b class="nc">&nbsp;			_ctx.stop = _input.LT(-1);</b>
<b class="nc">&nbsp;			setState(41);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			_alt = getInterpreter().adaptivePredict(_input,4,_ctx);</b>
<b class="nc">&nbsp;			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</b>
<b class="nc">&nbsp;				if ( _alt==1 ) {</b>
<b class="nc">&nbsp;					if ( _parseListeners!=null ) triggerExitRuleEvent();</b>
<b class="nc">&nbsp;					_prevctx = _localctx;</b>
&nbsp;					{
<b class="nc">&nbsp;					setState(39);</b>
<b class="nc">&nbsp;					_errHandler.sync(this);</b>
<b class="nc">&nbsp;					switch ( getInterpreter().adaptivePredict(_input,3,_ctx) ) {</b>
&nbsp;					case 1:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						((BinaryExpressionContext)_localctx).left = _prevctx;</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expression);</b>
<b class="nc">&nbsp;						setState(33);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 3)&quot;);</b>
<b class="nc">&nbsp;						setState(34);</b>
<b class="nc">&nbsp;						((BinaryExpressionContext)_localctx).bin_op = match(AND);</b>
<b class="nc">&nbsp;						setState(35);</b>
<b class="nc">&nbsp;						((BinaryExpressionContext)_localctx).right = expression(4);</b>
&nbsp;						}
&nbsp;						break;
&nbsp;					case 2:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						((BinaryExpressionContext)_localctx).left = _prevctx;</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expression);</b>
<b class="nc">&nbsp;						setState(36);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 2)&quot;);</b>
<b class="nc">&nbsp;						setState(37);</b>
<b class="nc">&nbsp;						((BinaryExpressionContext)_localctx).bin_op = match(OR);</b>
<b class="nc">&nbsp;						setState(38);</b>
<b class="nc">&nbsp;						((BinaryExpressionContext)_localctx).right = expression(3);</b>
&nbsp;						}
&nbsp;						break;
&nbsp;					}
&nbsp;					} 
&nbsp;				}
<b class="nc">&nbsp;				setState(43);</b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_alt = getInterpreter().adaptivePredict(_input,4,_ctx);</b>
&nbsp;			}
&nbsp;			}
&nbsp;		}
&nbsp;		catch (RecognitionException re) {
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			unrollRecursionContexts(_parentctx);</b>
&nbsp;		}
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ComparisonContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode FIELD() { return getToken(SearchParser.FIELD, 0); }</b>
&nbsp;		public OperatorContext operator() {
<b class="nc">&nbsp;			return getRuleContext(OperatorContext.class,0);</b>
&nbsp;		}
&nbsp;		public SearchValueContext searchValue() {
<b class="nc">&nbsp;			return getRuleContext(SearchValueContext.class,0);</b>
&nbsp;		}
&nbsp;		public ComparisonContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_comparison; }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterComparison(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitComparison(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitComparison(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final ComparisonContext comparison() throws RecognitionException {
<b class="nc">&nbsp;		ComparisonContext _localctx = new ComparisonContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 6, RULE_comparison);</b>
&nbsp;		try {
<b class="nc">&nbsp;			setState(49);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			switch ( getInterpreter().adaptivePredict(_input,5,_ctx) ) {</b>
&nbsp;			case 1:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 1);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(44);</b>
<b class="nc">&nbsp;				match(FIELD);</b>
<b class="nc">&nbsp;				setState(45);</b>
<b class="nc">&nbsp;				operator();</b>
<b class="nc">&nbsp;				setState(46);</b>
<b class="nc">&nbsp;				searchValue();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			case 2:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 2);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(48);</b>
<b class="nc">&nbsp;				searchValue();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;		}
&nbsp;		catch (RecognitionException re) {
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
&nbsp;		}
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class OperatorContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode EQUAL() { return getToken(SearchParser.EQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode CEQUAL() { return getToken(SearchParser.CEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode EEQUAL() { return getToken(SearchParser.EEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode CEEQUAL() { return getToken(SearchParser.CEEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode REQUAL() { return getToken(SearchParser.REQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode CREEQUAL() { return getToken(SearchParser.CREEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode NEQUAL() { return getToken(SearchParser.NEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode NCEQUAL() { return getToken(SearchParser.NCEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode NEEQUAL() { return getToken(SearchParser.NEEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode NCEEQUAL() { return getToken(SearchParser.NCEEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode NREQUAL() { return getToken(SearchParser.NREQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode NCREEQUAL() { return getToken(SearchParser.NCREEQUAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode CONTAINS() { return getToken(SearchParser.CONTAINS, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode MATCHES() { return getToken(SearchParser.MATCHES, 0); }</b>
&nbsp;		public OperatorContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_operator; }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterOperator(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitOperator(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitOperator(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final OperatorContext operator() throws RecognitionException {
<b class="nc">&nbsp;		OperatorContext _localctx = new OperatorContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 8, RULE_operator);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(51);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
<b class="nc">&nbsp;			if ( !((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 851952L) != 0)) ) {</b>
<b class="nc">&nbsp;			_errHandler.recoverInline(this);</b>
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="nc">&nbsp;				_errHandler.reportMatch(this);</b>
<b class="nc">&nbsp;				consume();</b>
&nbsp;			}
&nbsp;			}
&nbsp;		}
&nbsp;		catch (RecognitionException re) {
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
&nbsp;		}
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class SearchValueContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode STRING_LITERAL() { return getToken(SearchParser.STRING_LITERAL, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode FIELD() { return getToken(SearchParser.FIELD, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode TERM() { return getToken(SearchParser.TERM, 0); }</b>
&nbsp;		public SearchValueContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_searchValue; }</b>
&nbsp;		@Override
&nbsp;		public void enterRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).enterSearchValue(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public void exitRule(ParseTreeListener listener) {
<b class="nc">&nbsp;			if ( listener instanceof SearchListener ) ((SearchListener)listener).exitSearchValue(this);</b>
&nbsp;		}
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof SearchVisitor ) return ((SearchVisitor&lt;? extends T&gt;)visitor).visitSearchValue(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final SearchValueContext searchValue() throws RecognitionException {
<b class="nc">&nbsp;		SearchValueContext _localctx = new SearchValueContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 10, RULE_searchValue);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(53);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
<b class="nc">&nbsp;			if ( !((((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 14680064L) != 0)) ) {</b>
<b class="nc">&nbsp;			_errHandler.recoverInline(this);</b>
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="nc">&nbsp;				_errHandler.reportMatch(this);</b>
<b class="nc">&nbsp;				consume();</b>
&nbsp;			}
&nbsp;			}
&nbsp;		}
&nbsp;		catch (RecognitionException re) {
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
&nbsp;		}
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
<b class="nc">&nbsp;		switch (ruleIndex) {</b>
&nbsp;		case 2:
<b class="nc">&nbsp;			return expression_sempred((ExpressionContext)_localctx, predIndex);</b>
&nbsp;		}
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;	private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
<b class="nc">&nbsp;		switch (predIndex) {</b>
&nbsp;		case 0:
<b class="nc">&nbsp;			return precpred(_ctx, 3);</b>
&nbsp;		case 1:
<b class="nc">&nbsp;			return precpred(_ctx, 2);</b>
&nbsp;		}
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	public static final String _serializedATN =
&nbsp;		&quot;\u0004\u0001\u00178\u0002\u0000\u0007\u0000\u0002\u0001\u0007\u0001\u0002&quot;+
&nbsp;		&quot;\u0002\u0007\u0002\u0002\u0003\u0007\u0003\u0002\u0004\u0007\u0004\u0002&quot;+
&nbsp;		&quot;\u0005\u0007\u0005\u0001\u0000\u0001\u0000\u0001\u0000\u0001\u0000\u0003&quot;+
&nbsp;		&quot;\u0000\u0011\b\u0000\u0001\u0001\u0004\u0001\u0014\b\u0001\u000b\u0001&quot;+
&nbsp;		&quot;\f\u0001\u0015\u0001\u0002\u0001\u0002\u0001\u0002\u0001\u0002\u0001\u0002&quot;+
&nbsp;		&quot;\u0001\u0002\u0001\u0002\u0001\u0002\u0003\u0002 \b\u0002\u0001\u0002&quot;+
&nbsp;		&quot;\u0001\u0002\u0001\u0002\u0001\u0002\u0001\u0002\u0001\u0002\u0005\u0002&quot;+
&nbsp;		&quot;(\b\u0002\n\u0002\f\u0002+\t\u0002\u0001\u0003\u0001\u0003\u0001\u0003&quot;+
&nbsp;		&quot;\u0001\u0003\u0001\u0003\u0003\u00032\b\u0003\u0001\u0004\u0001\u0004&quot;+
&nbsp;		&quot;\u0001\u0005\u0001\u0005\u0001\u0005\u0000\u0001\u0004\u0006\u0000\u0002&quot;+
&nbsp;		&quot;\u0004\u0006\b\n\u0000\u0002\u0002\u0000\u0004\u000f\u0012\u0013\u0001&quot;+
&nbsp;		&quot;\u0000\u0015\u00178\u0000\u0010\u0001\u0000\u0000\u0000\u0002\u0013\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u0004\u001f\u0001\u0000\u0000\u0000\u00061\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\b3\u0001\u0000\u0000\u0000\n5\u0001\u0000\u0000\u0000\f\u0011&quot;+
&nbsp;		&quot;\u0005\u0000\u0000\u0001\r\u000e\u0003\u0002\u0001\u0000\u000e\u000f\u0005&quot;+
&nbsp;		&quot;\u0000\u0000\u0001\u000f\u0011\u0001\u0000\u0000\u0000\u0010\f\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\u0010\r\u0001\u0000\u0000\u0000\u0011\u0001\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u0012\u0014\u0003\u0004\u0002\u0000\u0013\u0012\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u0014\u0015\u0001\u0000\u0000\u0000\u0015\u0013\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u0015\u0016\u0001\u0000\u0000\u0000\u0016\u0003\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u0017\u0018\u0006\u0002\uffff\uffff\u0000\u0018\u0019\u0005\u0002&quot;+
&nbsp;		&quot;\u0000\u0000\u0019\u001a\u0003\u0002\u0001\u0000\u001a\u001b\u0005\u0003&quot;+
&nbsp;		&quot;\u0000\u0000\u001b \u0001\u0000\u0000\u0000\u001c\u001d\u0005\u0014\u0000&quot;+
&nbsp;		&quot;\u0000\u001d \u0003\u0004\u0002\u0004\u001e \u0003\u0006\u0003\u0000\u001f&quot;+
&nbsp;		&quot;\u0017\u0001\u0000\u0000\u0000\u001f\u001c\u0001\u0000\u0000\u0000\u001f&quot;+
&nbsp;		&quot;\u001e\u0001\u0000\u0000\u0000 )\u0001\u0000\u0000\u0000!\&quot;\n\u0003\u0000&quot;+
&nbsp;		&quot;\u0000\&quot;#\u0005\u0010\u0000\u0000#(\u0003\u0004\u0002\u0004$%\n\u0002&quot;+
&nbsp;		&quot;\u0000\u0000%&amp;\u0005\u0011\u0000\u0000&amp;(\u0003\u0004\u0002\u0003\&#39;!\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\&#39;$\u0001\u0000\u0000\u0000(+\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;)\&#39;\u0001\u0000\u0000\u0000)*\u0001\u0000\u0000\u0000*\u0005\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000+)\u0001\u0000\u0000\u0000,-\u0005\u0015\u0000\u0000-.\u0003&quot;+
&nbsp;		&quot;\b\u0004\u0000./\u0003\n\u0005\u0000/2\u0001\u0000\u0000\u000002\u0003&quot;+
&nbsp;		&quot;\n\u0005\u00001,\u0001\u0000\u0000\u000010\u0001\u0000\u0000\u00002\u0007&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u000034\u0007\u0000\u0000\u00004\t\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u000056\u0007\u0001\u0000\u00006\u000b\u0001\u0000\u0000\u0000\u0006&quot;+
&nbsp;		&quot;\u0010\u0015\u001f\&#39;)1&quot;;
<b class="nc">&nbsp;	public static final ATN _ATN =</b>
<b class="nc">&nbsp;		new ATNDeserializer().deserialize(_serializedATN.toCharArray());</b>
&nbsp;	static {
<b class="nc">&nbsp;		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; _ATN.getNumberOfDecisions(); i++) {</b>
<b class="nc">&nbsp;			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
