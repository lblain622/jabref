


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BibEntryWriter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.logic.bibtex</a>
</div>

<h1>Coverage Summary for Class: BibEntryWriter (org.jabref.logic.bibtex)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BibEntryWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/87)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.logic.bibtex;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.StringWriter;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.SortedSet;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import org.jabref.logic.exporter.BibWriter;
&nbsp;import org.jabref.logic.os.OS;
&nbsp;import org.jabref.model.database.BibDatabaseMode;
&nbsp;import org.jabref.model.entry.BibEntry;
&nbsp;import org.jabref.model.entry.BibEntryType;
&nbsp;import org.jabref.model.entry.BibEntryTypesManager;
&nbsp;import org.jabref.model.entry.field.BibField;
&nbsp;import org.jabref.model.entry.field.Field;
&nbsp;import org.jabref.model.entry.field.InternalField;
&nbsp;import org.jabref.model.entry.field.OrFields;
&nbsp;import org.jabref.model.strings.StringUtil;
&nbsp;import org.jabref.model.util.Range;
&nbsp;
&nbsp;import io.github.adr.linked.ADR;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/// Parsing is done at {@link org.jabref.logic.importer.fileformat.BibtexParser}
&nbsp;public class BibEntryWriter {
&nbsp;
<b class="nc">&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(BibEntryWriter.class);</b>
&nbsp;
<b class="nc">&nbsp;    private final Map&lt;Field, Range&gt; fieldPositions = new HashMap&lt;&gt;();</b>
&nbsp;    private final BibEntryTypesManager entryTypesManager;
&nbsp;    private final FieldWriter fieldWriter;
&nbsp;
<b class="nc">&nbsp;    public BibEntryWriter(FieldWriter fieldWriter, BibEntryTypesManager entryTypesManager) {</b>
<b class="nc">&nbsp;        this.fieldWriter = fieldWriter;</b>
<b class="nc">&nbsp;        this.entryTypesManager = entryTypesManager;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String serializeAll(List&lt;BibEntry&gt; entries, BibDatabaseMode databaseMode) throws IOException {
<b class="nc">&nbsp;        StringWriter writer = new StringWriter();</b>
<b class="nc">&nbsp;        BibWriter bibWriter = new BibWriter(writer, OS.NEWLINE);</b>
<b class="nc">&nbsp;        for (BibEntry entry : entries) {</b>
<b class="nc">&nbsp;            write(entry, bibWriter, databaseMode);</b>
&nbsp;        }
<b class="nc">&nbsp;        return writer.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    public void write(BibEntry entry, BibWriter out, BibDatabaseMode bibDatabaseMode) throws IOException {
<b class="nc">&nbsp;        write(entry, out, bibDatabaseMode, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Writes the given BibEntry using the given writer
&nbsp;    ///
&nbsp;    /// @param entry           The entry to write
&nbsp;    /// @param out             The writer to use
&nbsp;    /// @param bibDatabaseMode The database mode (bibtex or biblatex)
&nbsp;    /// @param reformat        Should the entry be in any case, even if no change occurred?
&nbsp;    public void write(BibEntry entry, BibWriter out, BibDatabaseMode bibDatabaseMode, boolean reformat) throws IOException {
&nbsp;        // if the entry has not been modified, write it as it was
<b class="nc">&nbsp;        if (!reformat &amp;&amp; !entry.hasChanged()) {</b>
<b class="nc">&nbsp;            out.write(entry.getParsedSerialization());</b>
<b class="nc">&nbsp;            out.finishBlock();</b>
&nbsp;            return;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        writeUserComments(entry, out);</b>
<b class="nc">&nbsp;        writeRequiredFieldsFirstRemainingFieldsSecond(entry, out, bibDatabaseMode);</b>
<b class="nc">&nbsp;        out.finishBlock();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void writeUserComments(BibEntry entry, BibWriter out) throws IOException {
<b class="nc">&nbsp;        String userComments = entry.getUserComments();</b>
&nbsp;
<b class="nc">&nbsp;        if (!userComments.isEmpty()) {</b>
<b class="nc">&nbsp;            out.write(userComments);</b>
&nbsp;            // ensure that a line break appears after the comment
<b class="nc">&nbsp;            out.finishLine();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /// Writes fields in the order of requiredFields, optionalFields and other fields, but does not sort the fields.
&nbsp;    private void writeRequiredFieldsFirstRemainingFieldsSecond(BibEntry entry, BibWriter out,
&nbsp;                                                               BibDatabaseMode bibDatabaseMode) throws IOException {
<b class="nc">&nbsp;        writeEntryType(entry, out, bibDatabaseMode);</b>
<b class="nc">&nbsp;        writeKeyField(entry, out);</b>
&nbsp;
<b class="nc">&nbsp;        Set&lt;Field&gt; written = new HashSet&lt;&gt;();</b>
<b class="nc">&nbsp;        written.add(InternalField.KEY_FIELD);</b>
<b class="nc">&nbsp;        final int indent = getLengthOfLongestFieldName(entry);</b>
&nbsp;
<b class="nc">&nbsp;        Optional&lt;BibEntryType&gt; type = entryTypesManager.enrich(entry.getType(), bibDatabaseMode);</b>
<b class="nc">&nbsp;        if (type.isPresent()) {</b>
&nbsp;            // Write required fields first
<b class="nc">&nbsp;            List&lt;Field&gt; requiredFields = type.get()</b>
<b class="nc">&nbsp;                                             .getRequiredFields()</b>
<b class="nc">&nbsp;                                             .stream()</b>
<b class="nc">&nbsp;                                             .map(OrFields::getFields)</b>
<b class="nc">&nbsp;                                             .flatMap(Collection::stream)</b>
<b class="nc">&nbsp;                                             .sorted(Comparator.comparing(Field::getName))</b>
<b class="nc">&nbsp;                                             .toList();</b>
<b class="nc">&nbsp;            for (Field field : requiredFields) {</b>
<b class="nc">&nbsp;                writeField(entry, out, field, indent);</b>
&nbsp;            }
<b class="nc">&nbsp;            written.addAll(requiredFields);</b>
&nbsp;
&nbsp;            // Then optional fields
<b class="nc">&nbsp;            List&lt;Field&gt; optionalFields = type.get()</b>
<b class="nc">&nbsp;                                             .getOptionalFields()</b>
<b class="nc">&nbsp;                                             .stream()</b>
<b class="nc">&nbsp;                                             .map(BibField::field)</b>
<b class="nc">&nbsp;                                             .sorted(Comparator.comparing(Field::getName))</b>
<b class="nc">&nbsp;                                             .toList();</b>
<b class="nc">&nbsp;            for (Field field : optionalFields) {</b>
<b class="nc">&nbsp;                writeField(entry, out, field, indent);</b>
&nbsp;            }
<b class="nc">&nbsp;            written.addAll(optionalFields);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Then write remaining fields in alphabetic order.
<b class="nc">&nbsp;        SortedSet&lt;Field&gt; remainingFields = entry.getFields()</b>
<b class="nc">&nbsp;                                                .stream()</b>
<b class="nc">&nbsp;                                                .filter(key -&gt; !written.contains(key))</b>
<b class="nc">&nbsp;                                                .collect(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(Field::getName))));</b>
<b class="nc">&nbsp;        for (Field field : remainingFields) {</b>
<b class="nc">&nbsp;            writeField(entry, out, field, indent);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Finally, end the entry.
<b class="nc">&nbsp;        out.writeLine(&quot;}&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void writeEntryType(BibEntry entry, BibWriter out, BibDatabaseMode bibDatabaseMode) throws IOException {
<b class="nc">&nbsp;        int start = out.getCurrentPosition();</b>
<b class="nc">&nbsp;        TypedBibEntry typedEntry = new TypedBibEntry(entry, bibDatabaseMode);</b>
<b class="nc">&nbsp;        out.write(&#39;@&#39; + typedEntry.getTypeForDisplay());</b>
<b class="nc">&nbsp;        int end = out.getCurrentPosition();</b>
<b class="nc">&nbsp;        fieldPositions.put(InternalField.TYPE_HEADER, new Range(start, end));</b>
<b class="nc">&nbsp;        out.write(&quot;{&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void writeKeyField(BibEntry entry, BibWriter out) throws IOException {
<b class="nc">&nbsp;        int start = out.getCurrentPosition();</b>
<b class="nc">&nbsp;        String keyField = StringUtil.shaveString(entry.getCitationKey().orElse(&quot;&quot;));</b>
<b class="nc">&nbsp;        out.write(keyField);</b>
<b class="nc">&nbsp;        int end = out.getCurrentPosition();</b>
<b class="nc">&nbsp;        fieldPositions.put(InternalField.KEY_FIELD, new Range(start, end));</b>
<b class="nc">&nbsp;        out.writeLine(&quot;,&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Write a single field, if it has any content.
&nbsp;    ///
&nbsp;    /// @param entry the entry to write
&nbsp;    /// @param out   the target of the write
&nbsp;    /// @param field the field
&nbsp;    /// @throws IOException In case of an IO error
&nbsp;    private void writeField(BibEntry entry, BibWriter out, Field field, int indent) throws IOException {
<b class="nc">&nbsp;        Optional&lt;String&gt; value = entry.getField(field);</b>
&nbsp;        // only write field if it is not empty
&nbsp;        // field.ifPresent does not work as an IOException may be thrown
<b class="nc">&nbsp;        if (value.isPresent() &amp;&amp; !value.get().trim().isEmpty()) {</b>
<b class="nc">&nbsp;            out.write(&quot;  &quot;);</b>
<b class="nc">&nbsp;            out.write(getFormattedFieldName(field, indent));</b>
&nbsp;            try {
<b class="nc">&nbsp;                int start = out.getCurrentPosition();</b>
<b class="nc">&nbsp;                out.write(fieldWriter.write(field, value.get()));</b>
<b class="nc">&nbsp;                int end = out.getCurrentPosition();</b>
<b class="nc">&nbsp;                fieldPositions.put(field, new Range(start, end));</b>
&nbsp;            } catch (InvalidFieldValueException ex) {
<b class="nc">&nbsp;                LOGGER.warn(&quot;Invalid field value {} of field {} of entry {}&quot;, value.get(), field, entry.getCitationKey().orElse(&quot;&quot;), ex);</b>
<b class="nc">&nbsp;                throw new IOException(&quot;Error in field &#39;&quot; + field + &quot; of entry &quot; + entry.getCitationKey().orElse(&quot;&quot;) + &quot;&#39;: &quot; + ex.getMessage(), ex);</b>
&nbsp;            }
<b class="nc">&nbsp;            out.writeLine(&quot;,&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static int getLengthOfLongestFieldName(BibEntry entry) {
<b class="nc">&nbsp;        Predicate&lt;Field&gt; isNotCitationKey = field -&gt; InternalField.KEY_FIELD != field;</b>
<b class="nc">&nbsp;        return entry.getFields()</b>
<b class="nc">&nbsp;                    .stream()</b>
<b class="nc">&nbsp;                    .filter(isNotCitationKey)</b>
<b class="nc">&nbsp;                    .mapToInt(field -&gt; field.getName().length())</b>
<b class="nc">&nbsp;                    .max()</b>
<b class="nc">&nbsp;                    .orElse(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Get serializable version of field name with trailing spaces and the equal sign.
&nbsp;    ///
&nbsp;    /// @param field The name of the field.
&nbsp;    /// @return The display version of the field name.
&nbsp;    @ADR(49)
&nbsp;    static String getFormattedFieldName(Field field, int indent) {
<b class="nc">&nbsp;        String fieldName = field.getName();</b>
<b class="nc">&nbsp;        return fieldName + StringUtil.repeatSpaces(indent - fieldName.length()) + &quot; = &quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Map&lt;Field, Range&gt; getFieldPositions() {
<b class="nc">&nbsp;        return fieldPositions;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
