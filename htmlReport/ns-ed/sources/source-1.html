


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BibliographyConsistencyCheck</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.logic.quality.consistency</a>
</div>

<h1>Coverage Summary for Class: BibliographyConsistencyCheck (org.jabref.logic.quality.consistency)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BibliographyConsistencyCheck</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/61)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BibliographyConsistencyCheck$EntryTypeResult</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">BibliographyConsistencyCheck$Result</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/63)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.logic.quality.consistency;
&nbsp;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.SequencedCollection;
&nbsp;import java.util.Set;
&nbsp;import java.util.function.BiConsumer;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import org.jabref.logic.bibtex.comparator.BibEntryByCitationKeyComparator;
&nbsp;import org.jabref.logic.bibtex.comparator.BibEntryByFieldsComparator;
&nbsp;import org.jabref.logic.bibtex.comparator.FieldComparatorStack;
&nbsp;import org.jabref.model.database.BibDatabaseContext;
&nbsp;import org.jabref.model.database.BibDatabaseMode;
&nbsp;import org.jabref.model.entry.BibEntry;
&nbsp;import org.jabref.model.entry.BibEntryType;
&nbsp;import org.jabref.model.entry.field.Field;
&nbsp;import org.jabref.model.entry.field.InternalField;
&nbsp;import org.jabref.model.entry.field.SpecialField;
&nbsp;import org.jabref.model.entry.field.StandardField;
&nbsp;import org.jabref.model.entry.field.UserSpecificCommentField;
&nbsp;import org.jabref.model.entry.types.BiblatexEntryTypeDefinitions;
&nbsp;import org.jabref.model.entry.types.BibtexEntryTypeDefinitions;
&nbsp;import org.jabref.model.entry.types.EntryType;
&nbsp;
&nbsp;import com.google.common.annotations.VisibleForTesting;
&nbsp;
<b class="nc">&nbsp;public class BibliographyConsistencyCheck {</b>
&nbsp;
<b class="nc">&nbsp;    private static final Set&lt;Field&gt; EXPLICITLY_EXCLUDED_FIELDS = Set.of(</b>
&nbsp;            InternalField.KEY_FIELD, // Citation key
&nbsp;            StandardField.KEY,
&nbsp;            StandardField.COMMENT,
&nbsp;            StandardField.CROSSREF,
&nbsp;            StandardField.CITES,
&nbsp;            StandardField.PDF,
&nbsp;            StandardField.REVIEW,
&nbsp;            StandardField.SORTKEY,
&nbsp;            StandardField.SORTNAME,
&nbsp;            StandardField.TYPE,
&nbsp;            StandardField.XREF,
&nbsp;
&nbsp;            // JabRef-specific
&nbsp;            StandardField.GROUPS,
&nbsp;            StandardField.OWNER,
&nbsp;            StandardField.CITATIONCOUNT,
&nbsp;            StandardField.TIMESTAMP,
&nbsp;            StandardField.CREATIONDATE,
&nbsp;            StandardField.MODIFICATIONDATE
&nbsp;    );
&nbsp;
&nbsp;    private static Set&lt;Field&gt; filterExcludedFields(Collection&lt;Field&gt; fields) {
<b class="nc">&nbsp;        return fields.stream()</b>
<b class="nc">&nbsp;                     .filter(field -&gt; !EXPLICITLY_EXCLUDED_FIELDS.contains(field))</b>
<b class="nc">&nbsp;                     .filter(field -&gt; !StandardField.AUTOMATIC_FIELDS.contains(field))</b>
<b class="nc">&nbsp;                     .filter(field -&gt; !(field instanceof SpecialField))</b>
<b class="nc">&nbsp;                     .filter(field -&gt; !(field instanceof UserSpecificCommentField))</b>
<b class="nc">&nbsp;                     .collect(Collectors.toSet());</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Filters the given entries to those that violate consistency:
&nbsp;    ///
&nbsp;    /// - Fields not set (but set in other entries of the same type)
&nbsp;    /// - Required fields not set
&nbsp;    ///
&nbsp;    /// Additionally, the entries are sorted
&nbsp;    @VisibleForTesting
&nbsp;    List&lt;BibEntry&gt; filterAndSortEntriesWithFieldDifferences(Set&lt;BibEntry&gt; entries, Set&lt;Field&gt; differingFields, Set&lt;Field&gt; requiredFields) {
<b class="nc">&nbsp;        return entries.stream()</b>
<b class="nc">&nbsp;                      .filter(entry -&gt;</b>
&nbsp;                              // This removes entries that have all differing fields set (could be confusing to the user)
<b class="nc">&nbsp;                              !Collections.disjoint(entry.getFields(), differingFields)</b>
&nbsp;                                      // This ensures that all entries with missing required fields are included
<b class="nc">&nbsp;                                      || !entry.getFields().containsAll(requiredFields))</b>
<b class="nc">&nbsp;                      .sorted(new FieldComparatorStack&lt;&gt;(List.of(</b>
&nbsp;                              new BibEntryByCitationKeyComparator(),
&nbsp;                              new BibEntryByFieldsComparator()
&nbsp;                      )))
<b class="nc">&nbsp;                      .toList();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public record Result(Map&lt;EntryType, EntryTypeResult&gt; entryTypeToResultMap) {</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public record EntryTypeResult(Collection&lt;Field&gt; fields, SequencedCollection&lt;BibEntry&gt; sortedEntries) {</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks the consistency of the given entries by looking at the present and absent fields.
&nbsp;     * &lt;p&gt;
&nbsp;     * Computation takes place grouped by each entryType.
&nbsp;     * Computes the fields set in all entries. In case entries of the same type has more fields defined, it is output.
&nbsp;     * &lt;p&gt;
&nbsp;     * This class &lt;em&gt;does not&lt;/em&gt; check whether all required fields are present or if the fields are valid for the entry type.
&nbsp;     * That result can a) be retrieved by using the JabRef UI and b) by checking the CSV output of {@link BibliographyConsistencyCheckResultCsvWriter#writeFindings}
&nbsp;     *
&nbsp;     * @implNote This class does not implement {@link org.jabref.logic.integrity.DatabaseChecker}, because it returns a list of {@link org.jabref.logic.integrity.IntegrityMessage}, which are too fine-grained.
&nbsp;     */
&nbsp;    public Result check(BibDatabaseContext bibContext, BiConsumer&lt;Integer, Integer&gt; entriesGroupingProgress) {
&nbsp;        // collects fields existing in any entry, scoped by entry type
<b class="nc">&nbsp;        Map&lt;EntryType, Set&lt;Field&gt;&gt; entryTypeToFieldsInAnyEntryMap = new HashMap&lt;&gt;();</b>
&nbsp;        // collects fields existing in all entries, scoped by entry type
<b class="nc">&nbsp;        Map&lt;EntryType, Set&lt;Field&gt;&gt; entryTypeToFieldsInAllEntriesMap = new HashMap&lt;&gt;();</b>
&nbsp;        // collects entries of the same type
<b class="nc">&nbsp;        Map&lt;EntryType, Set&lt;BibEntry&gt;&gt; entryTypeToEntriesMap = new HashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        collectEntriesIntoMaps(bibContext, entryTypeToFieldsInAnyEntryMap, entryTypeToFieldsInAllEntriesMap, entryTypeToEntriesMap);</b>
&nbsp;
&nbsp;        List&lt;BibEntryType&gt; entryTypeDefinitions;
<b class="nc">&nbsp;        if (bibContext.getMode() == BibDatabaseMode.BIBLATEX) {</b>
<b class="nc">&nbsp;            entryTypeDefinitions = BiblatexEntryTypeDefinitions.ALL;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            entryTypeDefinitions = BibtexEntryTypeDefinitions.ALL;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Use LinkedHashMap to preserve the order of Bib(tex|latex)EntryTypeDefinitions.ALL
<b class="nc">&nbsp;        Map&lt;EntryType, EntryTypeResult&gt; resultMap = new LinkedHashMap&lt;&gt;();</b>
&nbsp;
<b class="nc">&nbsp;        int counter = 0;</b>
<b class="nc">&nbsp;        for (Map.Entry&lt;EntryType, Set&lt;Field&gt;&gt; mapEntry : entryTypeToFieldsInAnyEntryMap.entrySet()) {</b>
<b class="nc">&nbsp;            entriesGroupingProgress.accept(counter++, entryTypeToFieldsInAnyEntryMap.size());</b>
<b class="nc">&nbsp;            EntryType entryType = mapEntry.getKey();</b>
<b class="nc">&nbsp;            Set&lt;Field&gt; fieldsInAnyEntry = mapEntry.getValue();</b>
<b class="nc">&nbsp;            Set&lt;Field&gt; fieldsInAllEntries = entryTypeToFieldsInAllEntriesMap.get(entryType);</b>
<b class="nc">&nbsp;            Set&lt;Field&gt; filteredFieldsInAnyEntry = filterExcludedFields(fieldsInAnyEntry);</b>
&nbsp;
<b class="nc">&nbsp;            Set&lt;Field&gt; differingFields = new HashSet&lt;&gt;(filteredFieldsInAnyEntry);</b>
<b class="nc">&nbsp;            differingFields.removeAll(fieldsInAllEntries);</b>
<b class="nc">&nbsp;            assert fieldsInAllEntries != null;</b>
&nbsp;
<b class="nc">&nbsp;            Optional&lt;BibEntryType&gt; typeDefOpt = entryTypeDefinitions.stream()</b>
<b class="nc">&nbsp;                                                                    .filter(def -&gt; def.getType().equals(entryType))</b>
<b class="nc">&nbsp;                                                                    .findFirst();</b>
&nbsp;
<b class="nc">&nbsp;            Set&lt;Field&gt; requiredFields = typeDefOpt.map(typeDef -&gt;</b>
<b class="nc">&nbsp;                    typeDef.getRequiredFields().stream()</b>
<b class="nc">&nbsp;                           .flatMap(orFields -&gt; orFields.getFields().stream())</b>
<b class="nc">&nbsp;                           .collect(Collectors.toSet())</b>
<b class="nc">&nbsp;            ).orElse(Set.of());</b>
&nbsp;
<b class="nc">&nbsp;            Set&lt;BibEntry&gt; entries = entryTypeToEntriesMap.get(entryType);</b>
<b class="nc">&nbsp;            assert entries != null;</b>
<b class="nc">&nbsp;            if (entries == null || entries.size() &lt;= 1 || differingFields.isEmpty()) {</b>
&nbsp;                // entries.size == 1 can happen if there is only one entry for one type. (E.g., only one `@Book` entry)
&nbsp;                continue;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            List&lt;BibEntry&gt; sortedEntries = filterAndSortEntriesWithFieldDifferences(entries, differingFields, requiredFields);</b>
<b class="nc">&nbsp;            if (!sortedEntries.isEmpty()) {</b>
<b class="nc">&nbsp;                resultMap.put(entryType, new EntryTypeResult(differingFields, sortedEntries));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new Result(resultMap);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static void collectEntriesIntoMaps(BibDatabaseContext bibContext, Map&lt;EntryType, Set&lt;Field&gt;&gt; entryTypeToFieldsInAnyEntryMap, Map&lt;EntryType, Set&lt;Field&gt;&gt; entryTypeToFieldsInAllEntriesMap, Map&lt;EntryType, Set&lt;BibEntry&gt;&gt; entryTypeToEntriesMap) {
<b class="nc">&nbsp;        BibDatabaseMode mode = bibContext.getMode();</b>
<b class="nc">&nbsp;        List&lt;BibEntry&gt; entries = bibContext.getEntries();</b>
&nbsp;
<b class="nc">&nbsp;        for (BibEntry entry : entries) {</b>
<b class="nc">&nbsp;            EntryType entryType = entry.getType();</b>
&nbsp;
<b class="nc">&nbsp;            Set&lt;Field&gt; filteredFields = filterExcludedFields(entry.getFields());</b>
&nbsp;
<b class="nc">&nbsp;            entryTypeToFieldsInAllEntriesMap</b>
<b class="nc">&nbsp;                    .computeIfAbsent(entryType, _ -&gt; new HashSet&lt;&gt;(filteredFields))</b>
<b class="nc">&nbsp;                    .retainAll(filteredFields);</b>
&nbsp;
<b class="nc">&nbsp;            entryTypeToFieldsInAnyEntryMap</b>
<b class="nc">&nbsp;                    .computeIfAbsent(entryType, _ -&gt; new HashSet&lt;&gt;())</b>
<b class="nc">&nbsp;                    .addAll(filteredFields);</b>
&nbsp;
<b class="nc">&nbsp;            entryTypeToEntriesMap</b>
<b class="nc">&nbsp;                    .computeIfAbsent(entryType, _ -&gt; new HashSet&lt;&gt;())</b>
<b class="nc">&nbsp;                    .add(entry);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
