


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ManageStudyDefinitionViewModel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.gui.slr</a>
</div>

<h1>Coverage Summary for Class: ManageStudyDefinitionViewModel (org.jabref.gui.slr)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ManageStudyDefinitionViewModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/79)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.gui.slr;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.nio.file.InvalidPathException;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.List;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import javafx.beans.property.Property;
&nbsp;import javafx.beans.property.SimpleStringProperty;
&nbsp;import javafx.beans.property.StringProperty;
&nbsp;import javafx.collections.FXCollections;
&nbsp;import javafx.collections.ObservableList;
&nbsp;
&nbsp;import org.jabref.gui.DialogService;
&nbsp;import org.jabref.gui.WorkspacePreferences;
&nbsp;import org.jabref.logic.crawler.StudyRepository;
&nbsp;import org.jabref.logic.crawler.StudyYamlParser;
&nbsp;import org.jabref.logic.git.GitHandler;
&nbsp;import org.jabref.logic.importer.ImportFormatPreferences;
&nbsp;import org.jabref.logic.importer.ImporterPreferences;
&nbsp;import org.jabref.logic.importer.SearchBasedFetcher;
&nbsp;import org.jabref.logic.importer.WebFetchers;
&nbsp;import org.jabref.logic.importer.fetcher.ACMPortalFetcher;
&nbsp;import org.jabref.logic.importer.fetcher.CompositeSearchBasedFetcher;
&nbsp;import org.jabref.logic.importer.fetcher.DBLPFetcher;
&nbsp;import org.jabref.logic.importer.fetcher.IEEE;
&nbsp;import org.jabref.logic.importer.fetcher.SpringerNatureWebFetcher;
&nbsp;import org.jabref.logic.l10n.Localization;
&nbsp;import org.jabref.model.study.Study;
&nbsp;import org.jabref.model.study.StudyDatabase;
&nbsp;import org.jabref.model.study.StudyQuery;
&nbsp;
&nbsp;import org.eclipse.jgit.api.errors.GitAPIException;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;
&nbsp;/**
&nbsp; * This class provides a model for managing study definitions.
&nbsp; * To visualize the model one can bind the properties to UI elements.
&nbsp; */
&nbsp;public class ManageStudyDefinitionViewModel {
<b class="nc">&nbsp;    private static final Logger LOGGER = LoggerFactory.getLogger(ManageStudyDefinitionViewModel.class);</b>
&nbsp;
<b class="nc">&nbsp;    private static final Set&lt;String&gt; DEFAULT_SELECTION = Set.of(</b>
&nbsp;            ACMPortalFetcher.FETCHER_NAME,
&nbsp;            IEEE.FETCHER_NAME,
&nbsp;            SpringerNatureWebFetcher.FETCHER_NAME,
&nbsp;            DBLPFetcher.FETCHER_NAME);
&nbsp;
<b class="nc">&nbsp;    private final StringProperty title = new SimpleStringProperty();</b>
<b class="nc">&nbsp;    private final ObservableList&lt;String&gt; authors = FXCollections.observableArrayList();</b>
<b class="nc">&nbsp;    private final ObservableList&lt;String&gt; researchQuestions = FXCollections.observableArrayList();</b>
<b class="nc">&nbsp;    private final ObservableList&lt;String&gt; queries = FXCollections.observableArrayList();</b>
<b class="nc">&nbsp;    private final ObservableList&lt;StudyCatalogItem&gt; databases = FXCollections.observableArrayList();</b>
&nbsp;
&nbsp;    // Hold the complement of databases for the selector
<b class="nc">&nbsp;    private final SimpleStringProperty directory = new SimpleStringProperty();</b>
&nbsp;
&nbsp;    private final DialogService dialogService;
&nbsp;
&nbsp;    private final WorkspacePreferences workspacePreferences;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for a new study
&nbsp;     */
&nbsp;    public ManageStudyDefinitionViewModel(ImportFormatPreferences importFormatPreferences,
&nbsp;                                          ImporterPreferences importerPreferences,
&nbsp;                                          WorkspacePreferences workspacePreferences,
<b class="nc">&nbsp;                                          DialogService dialogService) {</b>
<b class="nc">&nbsp;        databases.addAll(WebFetchers.getSearchBasedFetchers(importFormatPreferences, importerPreferences)</b>
<b class="nc">&nbsp;                                    .stream()</b>
<b class="nc">&nbsp;                                    .map(SearchBasedFetcher::getName)</b>
&nbsp;                                    // The user wants to select specific fetchers
&nbsp;                                    // The fetcher summarizing ALL fetchers can be emulated by selecting ALL fetchers (which happens rarely when doing an SLR)
<b class="nc">&nbsp;                                    .filter(name -&gt; !CompositeSearchBasedFetcher.FETCHER_NAME.equals(name))</b>
<b class="nc">&nbsp;                                    .map(name -&gt; {</b>
<b class="nc">&nbsp;                                        boolean enabled = DEFAULT_SELECTION.contains(name);</b>
<b class="nc">&nbsp;                                        return new StudyCatalogItem(name, enabled);</b>
&nbsp;                                    })
<b class="nc">&nbsp;                                    .toList());</b>
<b class="nc">&nbsp;        this.dialogService = Objects.requireNonNull(dialogService);</b>
<b class="nc">&nbsp;        this.workspacePreferences = Objects.requireNonNull(workspacePreferences);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor for an existing study
&nbsp;     *
&nbsp;     * @param study          The study to initialize the UI from
&nbsp;     * @param studyDirectory The path where the study resides
&nbsp;     */
&nbsp;    public ManageStudyDefinitionViewModel(Study study,
&nbsp;                                          Path studyDirectory,
&nbsp;                                          ImportFormatPreferences importFormatPreferences,
&nbsp;                                          ImporterPreferences importerPreferences,
&nbsp;                                          WorkspacePreferences workspacePreferences,
<b class="nc">&nbsp;                                          DialogService dialogService) {</b>
&nbsp;        // copy the content of the study object into the UI fields
<b class="nc">&nbsp;        authors.addAll(Objects.requireNonNull(study).getAuthors());</b>
<b class="nc">&nbsp;        title.setValue(study.getTitle());</b>
<b class="nc">&nbsp;        researchQuestions.addAll(study.getResearchQuestions());</b>
<b class="nc">&nbsp;        queries.addAll(study.getQueries().stream().map(StudyQuery::getQuery).toList());</b>
<b class="nc">&nbsp;        List&lt;StudyDatabase&gt; studyDatabases = study.getDatabases();</b>
<b class="nc">&nbsp;        databases.addAll(WebFetchers.getSearchBasedFetchers(importFormatPreferences, importerPreferences)</b>
<b class="nc">&nbsp;                                    .stream()</b>
<b class="nc">&nbsp;                                    .map(SearchBasedFetcher::getName)</b>
&nbsp;                                    // The user wants to select specific fetchers
&nbsp;                                    // The fetcher summarizing ALL fetchers can be emulated by selecting ALL fetchers (which happens rarely when doing an SLR)
<b class="nc">&nbsp;                                    .filter(name -&gt; !CompositeSearchBasedFetcher.FETCHER_NAME.equals(name))</b>
<b class="nc">&nbsp;                                    .map(name -&gt; {</b>
<b class="nc">&nbsp;                                        boolean enabled = studyDatabases.contains(new StudyDatabase(name, true));</b>
<b class="nc">&nbsp;                                        return new StudyCatalogItem(name, enabled);</b>
&nbsp;                                    })
<b class="nc">&nbsp;                                    .toList());</b>
&nbsp;
<b class="nc">&nbsp;        this.directory.set(Objects.requireNonNull(studyDirectory).toString());</b>
<b class="nc">&nbsp;        this.dialogService = Objects.requireNonNull(dialogService);</b>
<b class="nc">&nbsp;        this.workspacePreferences = Objects.requireNonNull(workspacePreferences);</b>
&nbsp;    }
&nbsp;
&nbsp;    public StringProperty getTitle() {
<b class="nc">&nbsp;        return title;</b>
&nbsp;    }
&nbsp;
&nbsp;    public StringProperty getDirectory() {
<b class="nc">&nbsp;        return directory;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ObservableList&lt;String&gt; getAuthors() {
<b class="nc">&nbsp;        return authors;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ObservableList&lt;String&gt; getResearchQuestions() {
<b class="nc">&nbsp;        return researchQuestions;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ObservableList&lt;String&gt; getQueries() {
<b class="nc">&nbsp;        return queries;</b>
&nbsp;    }
&nbsp;
&nbsp;    public ObservableList&lt;StudyCatalogItem&gt; getCatalogs() {
<b class="nc">&nbsp;        return databases;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addAuthor(String author) {
<b class="nc">&nbsp;        if (author.isBlank()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        authors.add(author);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addResearchQuestion(String researchQuestion) {
<b class="nc">&nbsp;        if (researchQuestion.isBlank() || researchQuestions.contains(researchQuestion)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        researchQuestions.add(researchQuestion);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void addQuery(String query) {
<b class="nc">&nbsp;        if (query.isBlank()) {</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        queries.add(query);</b>
&nbsp;    }
&nbsp;
&nbsp;    public SlrStudyAndDirectory saveStudy() {
<b class="nc">&nbsp;        Study study = new Study(</b>
&nbsp;                authors,
<b class="nc">&nbsp;                title.getValueSafe(),</b>
&nbsp;                researchQuestions,
<b class="nc">&nbsp;                queries.stream().map(StudyQuery::new).collect(Collectors.toList()),</b>
<b class="nc">&nbsp;                databases.stream().map(studyDatabaseItem -&gt; new StudyDatabase(studyDatabaseItem.getName(), studyDatabaseItem.isEnabled())).filter(StudyDatabase::isEnabled).collect(Collectors.toList()));</b>
&nbsp;        Path studyDirectory;
<b class="nc">&nbsp;        final String studyDirectoryAsString = directory.getValueSafe();</b>
&nbsp;        try {
<b class="nc">&nbsp;            studyDirectory = Path.of(studyDirectoryAsString);</b>
&nbsp;        } catch (InvalidPathException e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Invalid path was provided: {}&quot;, studyDirectoryAsString);</b>
<b class="nc">&nbsp;            dialogService.notify(Localization.lang(&quot;Unable to write to %0.&quot;, studyDirectoryAsString));</b>
&nbsp;            // We do not assume another path - we return that there is an invalid object.
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
<b class="nc">&nbsp;        Path studyDefinitionFile = studyDirectory.resolve(StudyRepository.STUDY_DEFINITION_FILE_NAME);</b>
&nbsp;        try {
<b class="nc">&nbsp;            new StudyYamlParser().writeStudyYamlFile(study, studyDefinitionFile);</b>
&nbsp;        } catch (IOException e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Could not write study file {}&quot;, studyDefinitionFile, e);</b>
<b class="nc">&nbsp;            dialogService.notify(Localization.lang(&quot;Please enter a valid file path.&quot;) +</b>
&nbsp;                    &quot;: &quot; + studyDirectoryAsString);
&nbsp;            // We do not assume another path - we return that there is an invalid object.
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            new GitHandler(studyDirectory).createCommitOnCurrentBranch(&quot;Update study definition&quot;, false);</b>
&nbsp;        } catch (IOException | GitAPIException e) {
<b class="nc">&nbsp;            LOGGER.error(&quot;Could not commit study definition file in directory {}&quot;, studyDirectory, e);</b>
<b class="nc">&nbsp;            dialogService.notify(Localization.lang(&quot;Please enter a valid file path.&quot;) +</b>
&nbsp;                    &quot;: &quot; + studyDirectory);
&nbsp;            // We continue nevertheless as the directory itself could be valid
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return new SlrStudyAndDirectory(study, studyDirectory);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Property&lt;String&gt; titleProperty() {
<b class="nc">&nbsp;        return title;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void setStudyDirectory(Optional&lt;Path&gt; studyRepositoryRoot) {
<b class="nc">&nbsp;        getDirectory().setValue(studyRepositoryRoot.map(Path::toString).orElseGet(() -&gt; getDirectory().getValueSafe()));</b>
&nbsp;    }
&nbsp;
&nbsp;    public void deleteAuthor(String item) {
<b class="nc">&nbsp;        authors.remove(item);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void deleteQuestion(String item) {
<b class="nc">&nbsp;        researchQuestions.remove(item);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void deleteQuery(String item) {
<b class="nc">&nbsp;        queries.remove(item);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void initializeSelectedCatalogs() {
<b class="nc">&nbsp;        List&lt;String&gt; selectedCatalogs = workspacePreferences.getSelectedSlrCatalogs();</b>
<b class="nc">&nbsp;        for (StudyCatalogItem catalog : databases) {</b>
<b class="nc">&nbsp;            catalog.setEnabled(selectedCatalogs.contains(catalog.getName()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public void updateSelectedCatalogs() {
<b class="nc">&nbsp;        List&lt;String&gt; selectedCatalogsList = databases.stream()</b>
<b class="nc">&nbsp;                                                     .filter(StudyCatalogItem::isEnabled)</b>
<b class="nc">&nbsp;                                                     .map(StudyCatalogItem::getName)</b>
<b class="nc">&nbsp;                                                     .collect(Collectors.toList());</b>
&nbsp;
<b class="nc">&nbsp;        workspacePreferences.setSelectedSlrCatalogs(selectedCatalogsList);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
