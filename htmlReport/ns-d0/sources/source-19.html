


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ReferImporter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.logic.importer.fileformat</a>
</div>

<h1>Coverage Summary for Class: ReferImporter (org.jabref.logic.importer.fileformat)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ReferImporter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/122)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.logic.importer.fileformat;
&nbsp;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.IOException;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import org.jabref.logic.citationkeypattern.CitationKeyGenerator;
&nbsp;import org.jabref.logic.importer.Importer;
&nbsp;import org.jabref.logic.importer.ParserResult;
&nbsp;import org.jabref.logic.l10n.Localization;
&nbsp;import org.jabref.logic.util.FileType;
&nbsp;import org.jabref.logic.util.StandardFileType;
&nbsp;import org.jabref.model.entry.AuthorList;
&nbsp;import org.jabref.model.entry.BibEntry;
&nbsp;import org.jabref.model.entry.field.Field;
&nbsp;import org.jabref.model.entry.field.InternalField;
&nbsp;import org.jabref.model.entry.field.StandardField;
&nbsp;import org.jabref.model.entry.types.EntryType;
&nbsp;import org.jabref.model.entry.types.StandardEntryType;
&nbsp;
&nbsp;/**
&nbsp; * This is BibIX variant of Refer.
&nbsp; * There is hardly any official document so fields are added taking standard refer type.
&nbsp; * Originally number of fields were less and overtime some of these modified or added by various management systems.
&nbsp; */
<b class="nc">&nbsp;public class ReferImporter extends Importer {</b>
&nbsp;
<b class="nc">&nbsp;    private static final Pattern Z_PATTERN = Pattern.compile(&quot;%0 .*&quot;);</b>
&nbsp;    private static final String ENDOFRECORD = &quot;__EOREOR__&quot;;
&nbsp;
&nbsp;    @Override
&nbsp;    public String getId() {
<b class="nc">&nbsp;        return &quot;refer-bibIX&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getName() {
<b class="nc">&nbsp;        return &quot;Refer/BibIX&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public FileType getFileType() {
<b class="nc">&nbsp;        return StandardFileType.TXT;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public String getDescription() {
<b class="nc">&nbsp;        return Localization.lang(&quot;Import for the Refer/BibIX file.&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean isRecognizedFormat(BufferedReader reader) throws IOException {
&nbsp;        // look for the &quot;%0 *&quot; line;
&nbsp;        String str;
<b class="nc">&nbsp;        while ((str = reader.readLine()) != null) {</b>
<b class="nc">&nbsp;            if (Z_PATTERN.matcher(str).matches()) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public ParserResult importDatabase(BufferedReader reader) throws IOException {
<b class="nc">&nbsp;        List&lt;BibEntry&gt; bibEntryList = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        StringBuilder sb = new StringBuilder();</b>
&nbsp;        String str;
<b class="nc">&nbsp;        boolean first = true;</b>
&nbsp;
&nbsp;        // add all entry/s present in the file
<b class="nc">&nbsp;        while ((str = reader.readLine()) != null) {</b>
<b class="nc">&nbsp;            if (str.indexOf(&quot;%0&quot;) == 0) {</b>
<b class="nc">&nbsp;                if (!first) {</b>
<b class="nc">&nbsp;                    sb.append(ENDOFRECORD);</b>
&nbsp;                }
<b class="nc">&nbsp;                first = false;</b>
&nbsp;            }
<b class="nc">&nbsp;            sb.append(str).append(&#39;\n&#39;);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        List&lt;String&gt; allEntries = new ArrayList&lt;&gt;(List.of(sb.toString().split(ENDOFRECORD)));</b>
<b class="nc">&nbsp;        stringToBibEntry(bibEntryList, allEntries);</b>
&nbsp;
<b class="nc">&nbsp;        return new ParserResult(bibEntryList);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void stringToBibEntry(List&lt;BibEntry&gt; bibEntryList, List&lt;String&gt; allEntries) {
<b class="nc">&nbsp;        Map&lt;Field, String&gt; fieldMap = new HashMap&lt;&gt;();</b>
&nbsp;        EntryType type;
&nbsp;        StringBuilder author;
&nbsp;        StringBuilder editor;
&nbsp;        AtomicBoolean isEdited;
&nbsp;
<b class="nc">&nbsp;        for (String entry : allEntries) {</b>
<b class="nc">&nbsp;            List&lt;String&gt; fields = new ArrayList&lt;&gt;(List.of(entry.trim().substring(1).split(&quot;\n%&quot;)));</b>
<b class="nc">&nbsp;            type = BibEntry.DEFAULT_TYPE;</b>
<b class="nc">&nbsp;            author = new StringBuilder();</b>
<b class="nc">&nbsp;            editor = new StringBuilder();</b>
<b class="nc">&nbsp;            isEdited = new AtomicBoolean(false);</b>
&nbsp;
<b class="nc">&nbsp;            for (String field : fields) {</b>
<b class="nc">&nbsp;                if (field.length() &lt; 3) {</b>
&nbsp;                    continue;
&nbsp;                }
<b class="nc">&nbsp;                String tag = field.substring(0, 1);</b>
<b class="nc">&nbsp;                String val = field.substring(2);</b>
&nbsp;
<b class="nc">&nbsp;                switch (tag) {</b>
&nbsp;                    case &quot;0&quot; -&gt;
<b class="nc">&nbsp;                            type = getType(val, isEdited);</b>
&nbsp;                    case &quot;7&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.EDITION, val);</b>
&nbsp;                    case &quot;A&quot; -&gt;
<b class="nc">&nbsp;                            addAuthor(author, val);</b>
&nbsp;                    case &quot;B&quot; -&gt;
<b class="nc">&nbsp;                            addTag(fieldMap, type, val, &quot;B&quot;);</b>
&nbsp;                    case &quot;C&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.ADDRESS, val);</b>
&nbsp;                    case &quot;D&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.YEAR, val);</b>
&nbsp;                    case &quot;E&quot; -&gt;
<b class="nc">&nbsp;                            addEditor(editor, val);</b>
&nbsp;                    case &quot;F&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(InternalField.KEY_FIELD, CitationKeyGenerator.cleanKey(val, &quot;&quot;));</b>
&nbsp;                    case &quot;G&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.LANGUAGE, val);</b>
&nbsp;                    case &quot;I&quot; -&gt;
<b class="nc">&nbsp;                            addTag(fieldMap, type, val, &quot;I&quot;);</b>
&nbsp;                    case &quot;J&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.putIfAbsent(StandardField.JOURNAL, val);</b>
&nbsp;                    case &quot;K&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.KEYWORDS, val);</b>
&nbsp;                    case &quot;N&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.ISSUE, val);</b>
&nbsp;                    case &quot;O&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.NOTE, val);</b>
&nbsp;                    case &quot;P&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.PAGES, val.replaceAll(&quot;([0-9]) *- *([0-9])&quot;, &quot;$1--$2&quot;));</b>
&nbsp;                    case &quot;R&quot; -&gt;
<b class="nc">&nbsp;                            addTag(fieldMap, type, val, &quot;R&quot;);</b>
&nbsp;                    case &quot;S&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.SERIES, val);</b>
&nbsp;                    case &quot;T&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.TITLE, val);</b>
&nbsp;                    case &quot;U&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.URL, val);</b>
&nbsp;                    case &quot;V&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.VOLUME, val);</b>
&nbsp;                    case &quot;X&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.ABSTRACT, val);</b>
&nbsp;                    case &quot;?&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.TRANSLATOR, val);</b>
&nbsp;                    case &quot;@&quot; -&gt;
<b class="nc">&nbsp;                            fieldMap.put(StandardField.ISBN, val);</b>
&nbsp;                    default -&gt;
<b class="nc">&nbsp;                            addTag(fieldMap, type, val, &quot;default&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            postFix(fieldMap, author, editor, isEdited);</b>
&nbsp;
<b class="nc">&nbsp;            BibEntry singleBibEntry = new BibEntry(type);</b>
<b class="nc">&nbsp;            singleBibEntry.setField(fieldMap);</b>
<b class="nc">&nbsp;            if (!entry.isEmpty()) {</b>
<b class="nc">&nbsp;                bibEntryList.add(singleBibEntry);</b>
&nbsp;            }
<b class="nc">&nbsp;            fieldMap.clear();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private EntryType getType(String val, AtomicBoolean isEdited) {
&nbsp;        EntryType type;
<b class="nc">&nbsp;        if (val.indexOf(&quot;Journal&quot;) == 0) {</b>
<b class="nc">&nbsp;            type = StandardEntryType.Article;</b>
<b class="nc">&nbsp;        } else if (val.indexOf(&quot;Book Section&quot;) == 0) {</b>
<b class="nc">&nbsp;            type = StandardEntryType.InCollection;</b>
<b class="nc">&nbsp;        } else if (val.indexOf(&quot;Book&quot;) == 0) {</b>
<b class="nc">&nbsp;            type = StandardEntryType.Book;</b>
<b class="nc">&nbsp;        } else if (val.indexOf(&quot;Edited Book&quot;) == 0) {</b>
<b class="nc">&nbsp;            isEdited.set(true);</b>
<b class="nc">&nbsp;            type = StandardEntryType.Book;</b>
<b class="nc">&nbsp;        } else if (val.indexOf(&quot;Conference&quot;) == 0) {</b>
<b class="nc">&nbsp;            type = StandardEntryType.InProceedings;</b>
<b class="nc">&nbsp;        } else if (val.indexOf(&quot;Report&quot;) == 0) {</b>
<b class="nc">&nbsp;            type = StandardEntryType.TechReport;</b>
<b class="nc">&nbsp;        } else if (val.indexOf(&quot;Review&quot;) == 0) {</b>
<b class="nc">&nbsp;            type = StandardEntryType.Article;</b>
<b class="nc">&nbsp;        } else if (val.indexOf(&quot;Thesis&quot;) == 0) {</b>
<b class="nc">&nbsp;            type = StandardEntryType.PhdThesis;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            type = BibEntry.DEFAULT_TYPE;</b>
&nbsp;        }
<b class="nc">&nbsp;        return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void addAuthor(StringBuilder auth, String val) {
<b class="nc">&nbsp;        if (auth.isEmpty()) {</b>
<b class="nc">&nbsp;            auth.append(val);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            auth.append(&quot; and &quot;).append(val);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void addEditor(StringBuilder edt, String val) {
<b class="nc">&nbsp;        if (edt.isEmpty()) {</b>
<b class="nc">&nbsp;            edt.append(val);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            edt.append(&quot; and &quot;).append(val);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void addTag(Map&lt;Field, String&gt; m, EntryType type, String val, String tag) {
<b class="nc">&nbsp;        switch (tag) {</b>
&nbsp;            case &quot;B&quot; -&gt; {
<b class="nc">&nbsp;                if (type.equals(StandardEntryType.Article)) {</b>
<b class="nc">&nbsp;                    m.put(StandardField.JOURNAL, val);</b>
<b class="nc">&nbsp;                } else if (type.equals(StandardEntryType.Book) || type.equals(StandardEntryType.InBook)) {</b>
<b class="nc">&nbsp;                    m.put(StandardField.SERIES, val);</b>
&nbsp;                } else {
&nbsp;                    /* type = inproceedings */
<b class="nc">&nbsp;                    m.put(StandardField.BOOKTITLE, val);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case &quot;I&quot; -&gt; {
<b class="nc">&nbsp;                if (type.equals(StandardEntryType.PhdThesis)) {</b>
<b class="nc">&nbsp;                    m.put(StandardField.SCHOOL, val);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    m.put(StandardField.PUBLISHER, val);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            case &quot;R&quot; -&gt; {
&nbsp;                // note: R can be type in thesis but format is unknown
<b class="nc">&nbsp;                String doi = val;</b>
<b class="nc">&nbsp;                if (doi.startsWith(&quot;doi:&quot;)) {</b>
<b class="nc">&nbsp;                    doi = doi.substring(4);</b>
&nbsp;                }
<b class="nc">&nbsp;                m.put(StandardField.DOI, doi);</b>
&nbsp;            }
&nbsp;            default -&gt; {
&nbsp;                // other fields e.g. header(if any), rights, table of content, government ordering, call number, price, location of archive/conference etc.
<b class="nc">&nbsp;                if (m.containsKey(StandardField.NOTE)) {</b>
<b class="nc">&nbsp;                    String oldValue = m.get(StandardField.NOTE);</b>
<b class="nc">&nbsp;                    String newValue = (oldValue == null ? &quot;&quot; : oldValue + &quot;; &quot;) + val;</b>
<b class="nc">&nbsp;                    m.put(StandardField.NOTE, newValue);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    m.put(StandardField.NOTE, val);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void postFix(Map&lt;Field, String&gt; hm, StringBuilder author, StringBuilder editor, AtomicBoolean isEditedBook) {
&nbsp;        // In some of the documentation editor name can be found in place of author name
<b class="nc">&nbsp;        if (isEditedBook.get() &amp;&amp; editor.toString().isEmpty()) {</b>
<b class="nc">&nbsp;            editor = new StringBuilder(author.toString());</b>
<b class="nc">&nbsp;            author = new StringBuilder();</b>
&nbsp;        }
&nbsp;
&nbsp;        // fix authors/editor comma
<b class="nc">&nbsp;        if (!&quot;&quot;.contentEquals(author)) {</b>
<b class="nc">&nbsp;            hm.put(StandardField.AUTHOR, fixAuthor(author.toString()));</b>
&nbsp;        }
<b class="nc">&nbsp;        if (!&quot;&quot;.contentEquals(editor)) {</b>
<b class="nc">&nbsp;            hm.put(StandardField.EDITOR, fixAuthor(editor.toString()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * We must be careful about the author names, since they can be presented differently
&nbsp;     * by different sources. Normally each %A tag brings one name, and we get the authors
&nbsp;     * separated by &quot; and &quot;. This is the correct behaviour.
&nbsp;     * One source lists the names separated by comma, with a comma at the end. We can detect
&nbsp;     * this format and fix it.
&nbsp;     *
&nbsp;     * @param s The author string
&nbsp;     * @return The fixed author string
&nbsp;     */
&nbsp;    private static String fixAuthor(String s) {
<b class="nc">&nbsp;        int index = s.indexOf(&quot; and &quot;);</b>
<b class="nc">&nbsp;        if (index &gt;= 0) {</b>
<b class="nc">&nbsp;            return AuthorList.fixAuthorLastNameFirst(s);</b>
&nbsp;        }
&nbsp;        // Look for the comma at the end:
<b class="nc">&nbsp;        index = s.lastIndexOf(&#39;,&#39;);</b>
<b class="nc">&nbsp;        if (index == (s.length() - 1)) {</b>
<b class="nc">&nbsp;            String mod = s.substring(0, s.length() - 1).replace(&quot;, &quot;, &quot; and &quot;);</b>
<b class="nc">&nbsp;            return AuthorList.fixAuthorLastNameFirst(mod);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return AuthorList.fixAuthorLastNameFirst(s);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
