


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BibEntryType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.jabref.model.entry</a>
</div>

<h1>Coverage Summary for Class: BibEntryType (org.jabref.model.entry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BibEntryType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (8/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (4/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.6%
  </span>
  <span class="absValue">
    (20/47)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.jabref.model.entry;
&nbsp;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.Objects;
&nbsp;import java.util.SequencedSet;
&nbsp;import java.util.Set;
&nbsp;import java.util.stream.Collectors;
&nbsp;
&nbsp;import org.jabref.model.database.BibDatabaseMode;
&nbsp;import org.jabref.model.entry.field.BibField;
&nbsp;import org.jabref.model.entry.field.Field;
&nbsp;import org.jabref.model.entry.field.FieldPriority;
&nbsp;import org.jabref.model.entry.field.OrFields;
&nbsp;import org.jabref.model.entry.field.StandardField;
&nbsp;import org.jabref.model.entry.types.EntryType;
&nbsp;
&nbsp;public class BibEntryType implements Comparable&lt;BibEntryType&gt; {
&nbsp;
&nbsp;    private final EntryType type;
&nbsp;    private final SequencedSet&lt;BibField&gt; allFields;
&nbsp;    private final SequencedSet&lt;OrFields&gt; requiredFields;
&nbsp;
&nbsp;    /**
&nbsp;     * Provides an enriched EntryType with information about defined standards as mandatory fields etc.
&nbsp;     * &lt;p&gt;
&nbsp;     * A builder is available at {@link BibEntryTypeBuilder}
&nbsp;     *
&nbsp;     * @param type           The EntryType this BibEntryType is wrapped around.
&nbsp;     * @param allFields      A BibFields list of all fields, including the required fields
&nbsp;     * @param requiredFields A OrFields list of just the required fields
&nbsp;     */
<b class="fc">&nbsp;    public BibEntryType(EntryType type, Collection&lt;BibField&gt; allFields, Collection&lt;OrFields&gt; requiredFields) {</b>
<b class="fc">&nbsp;        this.type = Objects.requireNonNull(type);</b>
<b class="fc">&nbsp;        this.allFields = new LinkedHashSet&lt;&gt;(allFields);</b>
<b class="fc">&nbsp;        this.requiredFields = new LinkedHashSet&lt;&gt;(requiredFields);</b>
&nbsp;    }
&nbsp;
&nbsp;    public EntryType getType() {
<b class="nc">&nbsp;        return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    public SequencedSet&lt;BibField&gt; getOptionalFields() {
<b class="fc">&nbsp;        return getAllBibFields().stream()</b>
<b class="fc">&nbsp;                                .filter(field -&gt; !isRequired(field.field()))</b>
<b class="fc">&nbsp;                                .collect(Collectors.toCollection(LinkedHashSet::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isRequired(Field field) {
<b class="fc">&nbsp;        return getRequiredFields().stream()</b>
<b class="fc">&nbsp;                                  .anyMatch(fields -&gt; fields.contains(field));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all required field names.
&nbsp;     * If fields have an OR relationship the name includes both field names divided by /, e.g. author/editor.
&nbsp;     * If you need all required fields as sole entities use @see{getRequiredFieldsFlat} .
&nbsp;     *
&nbsp;     * @return a Set of required field name Strings
&nbsp;     */
&nbsp;    public SequencedSet&lt;OrFields&gt; getRequiredFields() {
<b class="fc">&nbsp;        return Collections.unmodifiableSequencedSet(requiredFields);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all defined fields.
&nbsp;     */
&nbsp;    public SequencedSet&lt;BibField&gt; getAllBibFields() {
<b class="fc">&nbsp;        return Collections.unmodifiableSequencedSet(allFields);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;Field&gt; getAllFields() {
<b class="nc">&nbsp;        return allFields.stream().map(BibField::field).collect(Collectors.toCollection(LinkedHashSet::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    public SequencedSet&lt;Field&gt; getImportantOptionalFields() {
<b class="fc">&nbsp;        return getOptionalFields().stream()</b>
<b class="fc">&nbsp;                                  .filter(field -&gt; field.priority() == FieldPriority.IMPORTANT)</b>
<b class="fc">&nbsp;                                  .map(BibField::field)</b>
<b class="fc">&nbsp;                                  .collect(Collectors.toCollection(LinkedHashSet::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    public SequencedSet&lt;Field&gt; getDetailOptionalFields() {
<b class="fc">&nbsp;        return getOptionalFields().stream()</b>
<b class="fc">&nbsp;                                  .filter(field -&gt; field.priority() == FieldPriority.DETAIL)</b>
<b class="fc">&nbsp;                                  .map(BibField::field)</b>
<b class="fc">&nbsp;                                  .collect(Collectors.toCollection(LinkedHashSet::new));</b>
&nbsp;    }
&nbsp;
&nbsp;    public Set&lt;Field&gt; getDeprecatedFields(BibDatabaseMode mode) {
<b class="nc">&nbsp;        if (mode == BibDatabaseMode.BIBTEX) {</b>
<b class="nc">&nbsp;            return Set.of();</b>
&nbsp;        }
<b class="nc">&nbsp;        Set&lt;Field&gt; deprecatedFields = new HashSet&lt;&gt;(EntryConverter.FIELD_ALIASES_BIBTEX_TO_BIBLATEX.keySet());</b>
&nbsp;
&nbsp;        // Only the optional fields which are mapped to another BibLaTeX name should be shown as &quot;deprecated&quot;
<b class="nc">&nbsp;        deprecatedFields.retainAll(getOptionalFieldsAndAliases());</b>
&nbsp;
&nbsp;        // BibLaTeX aims for that field &quot;date&quot; is used
&nbsp;        // Thus, year + month is deprecated
&nbsp;        // However, year is used in the wild very often, so we do not mark that as default as deprecated
<b class="nc">&nbsp;        deprecatedFields.add(StandardField.MONTH);</b>
&nbsp;
<b class="nc">&nbsp;        return deprecatedFields;</b>
&nbsp;    }
&nbsp;
&nbsp;    public SequencedSet&lt;Field&gt; getDetailOptionalNotDeprecatedFields(BibDatabaseMode mode) {
<b class="nc">&nbsp;        SequencedSet&lt;Field&gt; optionalFieldsNotPrimaryOrDeprecated = new LinkedHashSet&lt;&gt;(getDetailOptionalFields());</b>
<b class="nc">&nbsp;        optionalFieldsNotPrimaryOrDeprecated.removeAll(getDeprecatedFields(mode));</b>
<b class="nc">&nbsp;        return optionalFieldsNotPrimaryOrDeprecated;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get list of all optional fields of this entry and all fields being source for a BibTeX to BibLaTeX conversion.
&nbsp;     */
&nbsp;    private SequencedSet&lt;Field&gt; getOptionalFieldsAndAliases() {
<b class="nc">&nbsp;        SequencedSet&lt;Field&gt; optionalFieldsAndAliases = new LinkedHashSet&lt;&gt;(getOptionalFields().size());</b>
<b class="nc">&nbsp;        for (BibField field : getOptionalFields()) {</b>
<b class="nc">&nbsp;            optionalFieldsAndAliases.add(field.field());</b>
<b class="nc">&nbsp;            if (EntryConverter.FIELD_ALIASES_BIBTEX_TO_BIBLATEX.containsKey(field.field())) {</b>
<b class="nc">&nbsp;                optionalFieldsAndAliases.add(field.field());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return optionalFieldsAndAliases;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public boolean equals(Object o) {
<b class="nc">&nbsp;        if (this == o) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
<b class="nc">&nbsp;        if ((o == null) || (getClass() != o.getClass())) {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;        BibEntryType that = (BibEntryType) o;</b>
<b class="nc">&nbsp;        return type.equals(that.type) &amp;&amp;</b>
<b class="nc">&nbsp;                Objects.equals(requiredFields, that.requiredFields) &amp;&amp;</b>
<b class="nc">&nbsp;                Objects.equals(allFields, that.allFields);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public int hashCode() {
<b class="fc">&nbsp;        return Objects.hash(type, requiredFields, allFields);</b>
&nbsp;    }
&nbsp;
&nbsp;    /// Generates a **single line** string containing the information. This is used for debugging purposes.
&nbsp;    /// See &quot;&lt;a href=&quot;https://biratkirat.medium.com/learning-effective-java-item-10-84cc3ab553bc&quot;&gt;Effective Java, Item 10&lt;/a&gt;&quot; for a discussion on contracts.
&nbsp;    /// We are sure, we are using this method in a) logs (which should use single lines for output) and b) in the UI. For the UI, we use [org.jabref.gui.importer.BibEntryTypePrefsAndFileViewModel],
&nbsp;    /// which in turn uses [#serializeCustomEntryTypes(BibEntryType)]
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="nc">&nbsp;        return &quot;BibEntryType{&quot; +</b>
&nbsp;                &quot;type=&quot; + type +
&nbsp;                &quot;, allFields=&quot; + allFields +
&nbsp;                &quot;, requiredFields=&quot; + requiredFields +
&nbsp;                &#39;}&#39;;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * WARNING! This does not follow the equals contract. Even if this here returns 0, the objects can be different.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int compareTo(BibEntryType o) {
<b class="nc">&nbsp;        return this.getType().getName().compareTo(o.getType().getName());</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-09-29 22:51</div>
</div>
</body>
</html>
